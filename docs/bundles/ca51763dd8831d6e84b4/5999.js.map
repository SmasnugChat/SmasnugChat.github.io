{"version":3,"file":"bundles/ca51763dd8831d6e84b4/5999.js","mappings":"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","sources":["webpack://element-web/./node_modules/@zxcvbn-ts/core/src/Feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/Matching.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/Options.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/TimeEstimates.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/data/const.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/data/dateSplits.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/data/l33tTable.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/data/translationKeys.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/debounce.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/helper.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/index.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/levenshtein.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/bruteforce/feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/bruteforce/scoring.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/date/feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/date/matching.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/date/scoring.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/matching.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/scoring.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/l33t.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/reverse.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/unmunger/TrieNode.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/unmunger/getCleanPasswords.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/unmunger/l33tTableToTrieNode.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/scoring/l33t.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/scoring/uppercase.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/regex/feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/regex/matching.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/regex/scoring.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/repeat/feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/repeat/matching.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/repeat/scoring.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/separator/feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/separator/matching.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/separator/scoring.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/sequence/feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/sequence/matching.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/sequence/scoring.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/spatial/feedback.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/spatial/matching.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/matcher/spatial/scoring.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/scoring/estimate.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/scoring/index.ts","webpack://element-web/./node_modules/@zxcvbn-ts/core/src/scoring/utils.ts","webpack://element-web/./node_modules/@zxcvbn-ts/language-common/src/index.ts","webpack://element-web/./node_modules/@zxcvbn-ts/language-en/src/index.ts","webpack://element-web/./node_modules/@zxcvbn-ts/language-en/src/translations.ts","webpack://element-web/./node_modules/fastest-levenshtein/mod.js"],"sourcesContent":["import { zxcvbnOptions } from './Options';\nimport bruteforceMatcher from './matcher/bruteforce/feedback';\nimport dateMatcher from './matcher/date/feedback';\nimport dictionaryMatcher from './matcher/dictionary/feedback';\nimport regexMatcher from './matcher/regex/feedback';\nimport repeatMatcher from './matcher/repeat/feedback';\nimport sequenceMatcher from './matcher/sequence/feedback';\nimport spatialMatcher from './matcher/spatial/feedback';\nimport separatorMatcher from './matcher/separator/feedback';\nconst defaultFeedback = {\n    warning: null,\n    suggestions: [],\n};\n/*\n * -------------------------------------------------------------------------------\n *  Generate feedback ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass Feedback {\n    constructor() {\n        this.matchers = {\n            bruteforce: bruteforceMatcher,\n            date: dateMatcher,\n            dictionary: dictionaryMatcher,\n            regex: regexMatcher,\n            repeat: repeatMatcher,\n            sequence: sequenceMatcher,\n            spatial: spatialMatcher,\n            separator: separatorMatcher,\n        };\n        this.defaultFeedback = {\n            warning: null,\n            suggestions: [],\n        };\n        this.setDefaultSuggestions();\n    }\n    setDefaultSuggestions() {\n        this.defaultFeedback.suggestions.push(zxcvbnOptions.translations.suggestions.useWords, zxcvbnOptions.translations.suggestions.noNeed);\n    }\n    getFeedback(score, sequence) {\n        if (sequence.length === 0) {\n            return this.defaultFeedback;\n        }\n        if (score > 2) {\n            return defaultFeedback;\n        }\n        const extraFeedback = zxcvbnOptions.translations.suggestions.anotherWord;\n        const longestMatch = this.getLongestMatch(sequence);\n        let feedback = this.getMatchFeedback(longestMatch, sequence.length === 1);\n        if (feedback !== null && feedback !== undefined) {\n            feedback.suggestions.unshift(extraFeedback);\n        }\n        else {\n            feedback = {\n                warning: null,\n                suggestions: [extraFeedback],\n            };\n        }\n        return feedback;\n    }\n    getLongestMatch(sequence) {\n        let longestMatch = sequence[0];\n        const slicedSequence = sequence.slice(1);\n        slicedSequence.forEach((match) => {\n            if (match.token.length > longestMatch.token.length) {\n                longestMatch = match;\n            }\n        });\n        return longestMatch;\n    }\n    getMatchFeedback(match, isSoleMatch) {\n        if (this.matchers[match.pattern]) {\n            return this.matchers[match.pattern](match, isSoleMatch);\n        }\n        if (zxcvbnOptions.matchers[match.pattern] &&\n            'feedback' in zxcvbnOptions.matchers[match.pattern]) {\n            return zxcvbnOptions.matchers[match.pattern].feedback(match, isSoleMatch);\n        }\n        return defaultFeedback;\n    }\n}\nexport default Feedback;\n//# sourceMappingURL=Feedback.js.map","import { extend, sorted } from './helper';\nimport dateMatcher from './matcher/date/matching';\nimport dictionaryMatcher from './matcher/dictionary/matching';\nimport regexMatcher from './matcher/regex/matching';\nimport repeatMatcher from './matcher/repeat/matching';\nimport sequenceMatcher from './matcher/sequence/matching';\nimport spatialMatcher from './matcher/spatial/matching';\nimport separatorMatcher from './matcher/separator/matching';\nimport { zxcvbnOptions } from './Options';\nclass Matching {\n    constructor() {\n        this.matchers = {\n            date: dateMatcher,\n            dictionary: dictionaryMatcher,\n            regex: regexMatcher,\n            // @ts-ignore => TODO resolve this type issue. This is because it is possible to be async\n            repeat: repeatMatcher,\n            sequence: sequenceMatcher,\n            spatial: spatialMatcher,\n            separator: separatorMatcher,\n        };\n    }\n    match(password) {\n        const matches = [];\n        const promises = [];\n        const matchers = [\n            ...Object.keys(this.matchers),\n            ...Object.keys(zxcvbnOptions.matchers),\n        ];\n        matchers.forEach((key) => {\n            if (!this.matchers[key] && !zxcvbnOptions.matchers[key]) {\n                return;\n            }\n            const Matcher = this.matchers[key]\n                ? this.matchers[key]\n                : zxcvbnOptions.matchers[key].Matching;\n            const usedMatcher = new Matcher();\n            const result = usedMatcher.match({\n                password,\n                omniMatch: this,\n            });\n            if (result instanceof Promise) {\n                result.then((response) => {\n                    extend(matches, response);\n                });\n                promises.push(result);\n            }\n            else {\n                extend(matches, result);\n            }\n        });\n        if (promises.length > 0) {\n            return new Promise((resolve, reject) => {\n                Promise.all(promises)\n                    .then(() => {\n                    resolve(sorted(matches));\n                })\n                    .catch((error) => {\n                    reject(error);\n                });\n            });\n        }\n        return sorted(matches);\n    }\n}\nexport default Matching;\n//# sourceMappingURL=Matching.js.map","import { buildRankedDictionary } from './helper';\nimport l33tTable from './data/l33tTable';\nimport translationKeys from './data/translationKeys';\nimport TrieNode from './matcher/dictionary/variants/matching/unmunger/TrieNode';\nimport l33tTableToTrieNode from './matcher/dictionary/variants/matching/unmunger/l33tTableToTrieNode';\nexport class Options {\n    constructor() {\n        this.matchers = {};\n        this.l33tTable = l33tTable;\n        this.trieNodeRoot = l33tTableToTrieNode(l33tTable, new TrieNode());\n        this.dictionary = {\n            userInputs: [],\n        };\n        this.rankedDictionaries = {};\n        this.rankedDictionariesMaxWordSize = {};\n        this.translations = translationKeys;\n        this.graphs = {};\n        this.useLevenshteinDistance = false;\n        this.levenshteinThreshold = 2;\n        this.l33tMaxSubstitutions = 100;\n        this.maxLength = 256;\n        this.setRankedDictionaries();\n    }\n    // eslint-disable-next-line max-statements,complexity\n    setOptions(options = {}) {\n        if (options.l33tTable) {\n            this.l33tTable = options.l33tTable;\n            this.trieNodeRoot = l33tTableToTrieNode(options.l33tTable, new TrieNode());\n        }\n        if (options.dictionary) {\n            this.dictionary = options.dictionary;\n            this.setRankedDictionaries();\n        }\n        if (options.translations) {\n            this.setTranslations(options.translations);\n        }\n        if (options.graphs) {\n            this.graphs = options.graphs;\n        }\n        if (options.useLevenshteinDistance !== undefined) {\n            this.useLevenshteinDistance = options.useLevenshteinDistance;\n        }\n        if (options.levenshteinThreshold !== undefined) {\n            this.levenshteinThreshold = options.levenshteinThreshold;\n        }\n        if (options.l33tMaxSubstitutions !== undefined) {\n            this.l33tMaxSubstitutions = options.l33tMaxSubstitutions;\n        }\n        if (options.maxLength !== undefined) {\n            this.maxLength = options.maxLength;\n        }\n    }\n    setTranslations(translations) {\n        if (this.checkCustomTranslations(translations)) {\n            this.translations = translations;\n        }\n        else {\n            throw new Error('Invalid translations object fallback to keys');\n        }\n    }\n    checkCustomTranslations(translations) {\n        let valid = true;\n        Object.keys(translationKeys).forEach((type) => {\n            if (type in translations) {\n                const translationType = type;\n                Object.keys(translationKeys[translationType]).forEach((key) => {\n                    if (!(key in translations[translationType])) {\n                        valid = false;\n                    }\n                });\n            }\n            else {\n                valid = false;\n            }\n        });\n        return valid;\n    }\n    setRankedDictionaries() {\n        const rankedDictionaries = {};\n        const rankedDictionariesMaxWorkSize = {};\n        Object.keys(this.dictionary).forEach((name) => {\n            rankedDictionaries[name] = buildRankedDictionary(this.dictionary[name]);\n            rankedDictionariesMaxWorkSize[name] =\n                this.getRankedDictionariesMaxWordSize(this.dictionary[name]);\n        });\n        this.rankedDictionaries = rankedDictionaries;\n        this.rankedDictionariesMaxWordSize = rankedDictionariesMaxWorkSize;\n    }\n    getRankedDictionariesMaxWordSize(list) {\n        const data = list.map((el) => {\n            if (typeof el !== 'string') {\n                return el.toString().length;\n            }\n            return el.length;\n        });\n        // do not use Math.max(...data) because it can result in max stack size error because every entry will be used as an argument\n        if (data.length === 0) {\n            return 0;\n        }\n        return data.reduce((a, b) => Math.max(a, b), -Infinity);\n    }\n    buildSanitizedRankedDictionary(list) {\n        const sanitizedInputs = [];\n        list.forEach((input) => {\n            const inputType = typeof input;\n            if (inputType === 'string' ||\n                inputType === 'number' ||\n                inputType === 'boolean') {\n                sanitizedInputs.push(input.toString().toLowerCase());\n            }\n        });\n        return buildRankedDictionary(sanitizedInputs);\n    }\n    extendUserInputsDictionary(dictionary) {\n        if (!this.dictionary.userInputs) {\n            this.dictionary.userInputs = [];\n        }\n        const newList = [...this.dictionary.userInputs, ...dictionary];\n        this.rankedDictionaries.userInputs =\n            this.buildSanitizedRankedDictionary(newList);\n        this.rankedDictionariesMaxWordSize.userInputs =\n            this.getRankedDictionariesMaxWordSize(newList);\n    }\n    addMatcher(name, matcher) {\n        if (this.matchers[name]) {\n            console.info(`Matcher ${name} already exists`);\n        }\n        else {\n            this.matchers[name] = matcher;\n        }\n    }\n}\nexport const zxcvbnOptions = new Options();\n//# sourceMappingURL=Options.js.map","import { zxcvbnOptions } from './Options';\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst MONTH = DAY * 31;\nconst YEAR = MONTH * 12;\nconst CENTURY = YEAR * 100;\nconst times = {\n    second: SECOND,\n    minute: MINUTE,\n    hour: HOUR,\n    day: DAY,\n    month: MONTH,\n    year: YEAR,\n    century: CENTURY,\n};\n/*\n * -------------------------------------------------------------------------------\n *  Estimates time for an attacker ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass TimeEstimates {\n    translate(displayStr, value) {\n        let key = displayStr;\n        if (value !== undefined && value !== 1) {\n            key += 's';\n        }\n        const { timeEstimation } = zxcvbnOptions.translations;\n        return timeEstimation[key].replace('{base}', `${value}`);\n    }\n    estimateAttackTimes(guesses) {\n        const crackTimesSeconds = {\n            onlineThrottling100PerHour: guesses / (100 / 3600),\n            onlineNoThrottling10PerSecond: guesses / 10,\n            offlineSlowHashing1e4PerSecond: guesses / 1e4,\n            offlineFastHashing1e10PerSecond: guesses / 1e10,\n        };\n        const crackTimesDisplay = {\n            onlineThrottling100PerHour: '',\n            onlineNoThrottling10PerSecond: '',\n            offlineSlowHashing1e4PerSecond: '',\n            offlineFastHashing1e10PerSecond: '',\n        };\n        Object.keys(crackTimesSeconds).forEach((scenario) => {\n            const seconds = crackTimesSeconds[scenario];\n            crackTimesDisplay[scenario] =\n                this.displayTime(seconds);\n        });\n        return {\n            crackTimesSeconds,\n            crackTimesDisplay,\n            score: this.guessesToScore(guesses),\n        };\n    }\n    guessesToScore(guesses) {\n        const DELTA = 5;\n        if (guesses < 1e3 + DELTA) {\n            // risky password: \"too guessable\"\n            return 0;\n        }\n        if (guesses < 1e6 + DELTA) {\n            // modest protection from throttled online attacks: \"very guessable\"\n            return 1;\n        }\n        if (guesses < 1e8 + DELTA) {\n            // modest protection from unthrottled online attacks: \"somewhat guessable\"\n            return 2;\n        }\n        if (guesses < 1e10 + DELTA) {\n            // modest protection from offline attacks: \"safely unguessable\"\n            // assuming a salted, slow hash function like bcrypt, scrypt, PBKDF2, argon, etc\n            return 3;\n        }\n        // strong protection from offline attacks under same scenario: \"very unguessable\"\n        return 4;\n    }\n    displayTime(seconds) {\n        let displayStr = 'centuries';\n        let base;\n        const timeKeys = Object.keys(times);\n        const foundIndex = timeKeys.findIndex((time) => seconds < times[time]);\n        if (foundIndex > -1) {\n            displayStr = timeKeys[foundIndex - 1];\n            if (foundIndex !== 0) {\n                base = Math.round(seconds / times[displayStr]);\n            }\n            else {\n                displayStr = 'ltSecond';\n            }\n        }\n        return this.translate(displayStr, base);\n    }\n}\nexport default TimeEstimates;\n//# sourceMappingURL=TimeEstimates.js.map","import dateSplits from './dateSplits';\nexport const DATE_MAX_YEAR = 2050;\nexport const DATE_MIN_YEAR = 1000;\nexport const DATE_SPLITS = dateSplits;\nexport const BRUTEFORCE_CARDINALITY = 10;\nexport const MIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000;\nexport const MIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10;\nexport const MIN_SUBMATCH_GUESSES_MULTI_CHAR = 50;\nexport const MIN_YEAR_SPACE = 20;\n// \\xbf-\\xdf is a range for almost all special uppercase letter like  and so on\nexport const START_UPPER = /^[A-Z\\xbf-\\xdf][^A-Z\\xbf-\\xdf]+$/;\nexport const END_UPPER = /^[^A-Z\\xbf-\\xdf]+[A-Z\\xbf-\\xdf]$/;\n// \\xdf-\\xff is a range for almost all special lowercase letter like  and so on\nexport const ALL_UPPER = /^[A-Z\\xbf-\\xdf]+$/;\nexport const ALL_UPPER_INVERTED = /^[^a-z\\xdf-\\xff]+$/;\nexport const ALL_LOWER = /^[a-z\\xdf-\\xff]+$/;\nexport const ALL_LOWER_INVERTED = /^[^A-Z\\xbf-\\xdf]+$/;\nexport const ONE_LOWER = /[a-z\\xdf-\\xff]/;\nexport const ONE_UPPER = /[A-Z\\xbf-\\xdf]/;\nexport const ALPHA_INVERTED = /[^A-Za-z\\xbf-\\xdf]/gi;\nexport const ALL_DIGIT = /^\\d+$/;\nexport const REFERENCE_YEAR = new Date().getFullYear();\nexport const REGEXEN = { recentYear: /19\\d\\d|200\\d|201\\d|202\\d/g };\n/* Separators */\nexport const SEPERATOR_CHARS = [\n    ' ',\n    ',',\n    ';',\n    ':',\n    '|',\n    '/',\n    '\\\\',\n    '_',\n    '.',\n    '-',\n];\nexport const SEPERATOR_CHAR_COUNT = SEPERATOR_CHARS.length;\n//# sourceMappingURL=const.js.map","export default {\n    4: [\n        // for length-4 strings, eg 1191 or 9111, two ways to split:\n        [1, 2],\n        [2, 3], // 91 1 1\n    ],\n    5: [\n        [1, 3],\n        [2, 3],\n        //  [2, 3], // 91 1 11    <- duplicate previous one\n        [2, 4], // 91 11 1    <- New and must be added as bug fix\n    ],\n    6: [\n        [1, 2],\n        [2, 4],\n        [4, 5], // 1991 1 1\n    ],\n    //  1111991\n    7: [\n        [1, 3],\n        [2, 3],\n        [4, 5],\n        [4, 6], // 1991 11 1\n    ],\n    8: [\n        [2, 4],\n        [4, 6], // 1991 11 11\n    ],\n};\n//# sourceMappingURL=dateSplits.js.map","export default {\n    a: ['4', '@'],\n    b: ['8'],\n    c: ['(', '{', '[', '<'],\n    d: ['6', '|)'],\n    e: ['3'],\n    f: ['#'],\n    g: ['6', '9', '&'],\n    h: ['#', '|-|'],\n    i: ['1', '!', '|'],\n    k: ['<', '|<'],\n    l: ['!', '1', '|', '7'],\n    m: ['^^', 'nn', '2n', '/\\\\\\\\/\\\\\\\\'],\n    n: ['//'],\n    o: ['0', '()'],\n    q: ['9'],\n    u: ['|_|'],\n    s: ['$', '5'],\n    t: ['+', '7'],\n    v: ['<', '>', '/'],\n    w: ['^/', 'uu', 'vv', '2u', '2v', '\\\\\\\\/\\\\\\\\/'],\n    x: ['%', '><'],\n    z: ['2'],\n};\n//# sourceMappingURL=l33tTable.js.map","export default {\n    warnings: {\n        straightRow: 'straightRow',\n        keyPattern: 'keyPattern',\n        simpleRepeat: 'simpleRepeat',\n        extendedRepeat: 'extendedRepeat',\n        sequences: 'sequences',\n        recentYears: 'recentYears',\n        dates: 'dates',\n        topTen: 'topTen',\n        topHundred: 'topHundred',\n        common: 'common',\n        similarToCommon: 'similarToCommon',\n        wordByItself: 'wordByItself',\n        namesByThemselves: 'namesByThemselves',\n        commonNames: 'commonNames',\n        userInputs: 'userInputs',\n        pwned: 'pwned',\n    },\n    suggestions: {\n        l33t: 'l33t',\n        reverseWords: 'reverseWords',\n        allUppercase: 'allUppercase',\n        capitalization: 'capitalization',\n        dates: 'dates',\n        recentYears: 'recentYears',\n        associatedYears: 'associatedYears',\n        sequences: 'sequences',\n        repeated: 'repeated',\n        longerKeyboardPattern: 'longerKeyboardPattern',\n        anotherWord: 'anotherWord',\n        useWords: 'useWords',\n        noNeed: 'noNeed',\n        pwned: 'pwned',\n    },\n    timeEstimation: {\n        ltSecond: 'ltSecond',\n        second: 'second',\n        seconds: 'seconds',\n        minute: 'minute',\n        minutes: 'minutes',\n        hour: 'hour',\n        hours: 'hours',\n        day: 'day',\n        days: 'days',\n        month: 'month',\n        months: 'months',\n        year: 'year',\n        years: 'years',\n        centuries: 'centuries',\n    },\n};\n//# sourceMappingURL=translationKeys.js.map","/**\n * @link https://davidwalsh.name/javascript-debounce-function\n * @param func needs to implement a function which is debounced\n * @param wait how long do you want to wait till the previous declared function is executed\n * @param isImmediate defines if you want to execute the function on the first execution or the last execution inside the time window. `true` for first and `false` for last.\n */\nexport default (func, wait, isImmediate) => {\n    let timeout;\n    return function debounce(...args) {\n        const context = this;\n        const later = () => {\n            timeout = undefined;\n            if (!isImmediate) {\n                func.apply(context, args);\n            }\n        };\n        const shouldCallNow = isImmediate && !timeout;\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(later, wait);\n        if (shouldCallNow) {\n            return func.apply(context, args);\n        }\n        return undefined;\n    };\n};\n//# sourceMappingURL=debounce.js.map","export const empty = (obj) => Object.keys(obj).length === 0;\nexport const extend = (listToExtend, list) => \n// eslint-disable-next-line prefer-spread\nlistToExtend.push.apply(listToExtend, list);\nexport const translate = (string, chrMap) => {\n    let newString = string;\n    Object.entries(chrMap).forEach(([key, value]) => {\n        const escapedKey = key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        const regex = new RegExp(escapedKey, 'g');\n        newString = newString.replace(regex, value);\n    });\n    return newString;\n};\n// mod implementation that works for negative numbers\nexport const mod = (n, m) => ((n % m) + m) % m;\n// sort on i primary, j secondary\nexport const sorted = (matches) => matches.sort((m1, m2) => m1.i - m2.i || m1.j - m2.j);\nexport const buildRankedDictionary = (orderedList) => {\n    const result = {};\n    let counter = 1; // rank starts at 1, not 0\n    orderedList.forEach((word) => {\n        result[word] = counter;\n        counter += 1;\n    });\n    return result;\n};\n//# sourceMappingURL=helper.js.map","import Matching from './Matching';\nimport scoring from './scoring';\nimport TimeEstimates from './TimeEstimates';\nimport Feedback from './Feedback';\nimport { zxcvbnOptions, Options } from './Options';\nimport debounce from './debounce';\nconst time = () => new Date().getTime();\nconst createReturnValue = (resolvedMatches, password, start) => {\n    const feedback = new Feedback();\n    const timeEstimates = new TimeEstimates();\n    const matchSequence = scoring.mostGuessableMatchSequence(password, resolvedMatches);\n    const calcTime = time() - start;\n    const attackTimes = timeEstimates.estimateAttackTimes(matchSequence.guesses);\n    return {\n        calcTime,\n        ...matchSequence,\n        ...attackTimes,\n        feedback: feedback.getFeedback(attackTimes.score, matchSequence.sequence),\n    };\n};\nconst main = (password, userInputs) => {\n    if (userInputs) {\n        zxcvbnOptions.extendUserInputsDictionary(userInputs);\n    }\n    const matching = new Matching();\n    return matching.match(password);\n};\nexport const zxcvbn = (password, userInputs) => {\n    const start = time();\n    const matches = main(password, userInputs);\n    if (matches instanceof Promise) {\n        throw new Error('You are using a Promised matcher, please use `zxcvbnAsync` for it.');\n    }\n    return createReturnValue(matches, password, start);\n};\nexport const zxcvbnAsync = async (password, userInputs) => {\n    const usedPassword = password.substring(0, zxcvbnOptions.maxLength);\n    const start = time();\n    const matches = await main(usedPassword, userInputs);\n    return createReturnValue(matches, usedPassword, start);\n};\nexport * from './types';\nexport { zxcvbnOptions, Options, debounce };\n//# sourceMappingURL=index.js.map","import { distance } from 'fastest-levenshtein';\nconst getUsedThreshold = (password, entry, threshold) => {\n    const isPasswordToShort = password.length <= entry.length;\n    const isThresholdLongerThanPassword = password.length <= threshold;\n    const shouldUsePasswordLength = isPasswordToShort || isThresholdLongerThanPassword;\n    // if password is too small use the password length divided by 4 while the threshold needs to be at least 1\n    return shouldUsePasswordLength ? Math.ceil(password.length / 4) : threshold;\n};\nconst findLevenshteinDistance = (password, rankedDictionary, threshold) => {\n    let foundDistance = 0;\n    const found = Object.keys(rankedDictionary).find((entry) => {\n        const usedThreshold = getUsedThreshold(password, entry, threshold);\n        if (Math.abs(password.length - entry.length) > usedThreshold) {\n            return false;\n        }\n        const foundEntryDistance = distance(password, entry);\n        const isInThreshold = foundEntryDistance <= usedThreshold;\n        if (isInThreshold) {\n            foundDistance = foundEntryDistance;\n        }\n        return isInThreshold;\n    });\n    if (found) {\n        return {\n            levenshteinDistance: foundDistance,\n            levenshteinDistanceEntry: found,\n        };\n    }\n    return {};\n};\nexport default findLevenshteinDistance;\n//# sourceMappingURL=levenshtein.js.map","export default () => {\n    return null;\n};\n//# sourceMappingURL=feedback.js.map","import { BRUTEFORCE_CARDINALITY, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, MIN_SUBMATCH_GUESSES_MULTI_CHAR, } from '../../data/const';\nexport default ({ token }) => {\n    let guesses = BRUTEFORCE_CARDINALITY ** token.length;\n    if (guesses === Number.POSITIVE_INFINITY) {\n        guesses = Number.MAX_VALUE;\n    }\n    let minGuesses;\n    // small detail: make bruteforce matches at minimum one guess bigger than smallest allowed\n    // submatch guesses, such that non-bruteforce submatches over the same [i..j] take precedence.\n    if (token.length === 1) {\n        minGuesses = MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1;\n    }\n    else {\n        minGuesses = MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1;\n    }\n    return Math.max(guesses, minGuesses);\n};\n//# sourceMappingURL=scoring.js.map","import { zxcvbnOptions } from '../../Options';\nexport default () => {\n    return {\n        warning: zxcvbnOptions.translations.warnings.dates,\n        suggestions: [zxcvbnOptions.translations.suggestions.dates],\n    };\n};\n//# sourceMappingURL=feedback.js.map","import { DATE_MAX_YEAR, DATE_MIN_YEAR, DATE_SPLITS, REFERENCE_YEAR, } from '../../data/const';\nimport { sorted } from '../../helper';\n/*\n * -------------------------------------------------------------------------------\n *  date matching ----------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchDate {\n    /*\n     * a \"date\" is recognized as:\n     *   any 3-tuple that starts or ends with a 2- or 4-digit year,\n     *   with 2 or 0 separator chars (1.1.91 or 1191),\n     *   maybe zero-padded (01-01-91 vs 1-1-91),\n     *   a month between 1 and 12,\n     *   a day between 1 and 31.\n     *\n     * note: this isn't true date parsing in that \"feb 31st\" is allowed,\n     * this doesn't check for leap years, etc.\n     *\n     * recipe:\n     * start with regex to find maybe-dates, then attempt to map the integers\n     * onto month-day-year to filter the maybe-dates into dates.\n     * finally, remove matches that are substrings of other matches to reduce noise.\n     *\n     * note: instead of using a lazy or greedy regex to find many dates over the full string,\n     * this uses a ^...$ regex against every substring of the password -- less performant but leads\n     * to every possible date match.\n     */\n    match({ password }) {\n        const matches = [\n            ...this.getMatchesWithoutSeparator(password),\n            ...this.getMatchesWithSeparator(password),\n        ];\n        const filteredMatches = this.filterNoise(matches);\n        return sorted(filteredMatches);\n    }\n    getMatchesWithSeparator(password) {\n        const matches = [];\n        const maybeDateWithSeparator = /^(\\d{1,4})([\\s/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/;\n        // # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n        for (let i = 0; i <= Math.abs(password.length - 6); i += 1) {\n            for (let j = i + 5; j <= i + 9; j += 1) {\n                if (j >= password.length) {\n                    break;\n                }\n                const token = password.slice(i, +j + 1 || 9e9);\n                const regexMatch = maybeDateWithSeparator.exec(token);\n                if (regexMatch != null) {\n                    const dmy = this.mapIntegersToDayMonthYear([\n                        parseInt(regexMatch[1], 10),\n                        parseInt(regexMatch[3], 10),\n                        parseInt(regexMatch[4], 10),\n                    ]);\n                    if (dmy != null) {\n                        matches.push({\n                            pattern: 'date',\n                            token,\n                            i,\n                            j,\n                            separator: regexMatch[2],\n                            year: dmy.year,\n                            month: dmy.month,\n                            day: dmy.day,\n                        });\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    // eslint-disable-next-line max-statements\n    getMatchesWithoutSeparator(password) {\n        const matches = [];\n        const maybeDateNoSeparator = /^\\d{4,8}$/;\n        const metric = (candidate) => Math.abs(candidate.year - REFERENCE_YEAR);\n        // # dates without separators are between length 4 '1191' and 8 '11111991'\n        for (let i = 0; i <= Math.abs(password.length - 4); i += 1) {\n            for (let j = i + 3; j <= i + 7; j += 1) {\n                if (j >= password.length) {\n                    break;\n                }\n                const token = password.slice(i, +j + 1 || 9e9);\n                if (maybeDateNoSeparator.exec(token)) {\n                    const candidates = [];\n                    const index = token.length;\n                    const splittedDates = DATE_SPLITS[index];\n                    splittedDates.forEach(([k, l]) => {\n                        const dmy = this.mapIntegersToDayMonthYear([\n                            parseInt(token.slice(0, k), 10),\n                            parseInt(token.slice(k, l), 10),\n                            parseInt(token.slice(l), 10),\n                        ]);\n                        if (dmy != null) {\n                            candidates.push(dmy);\n                        }\n                    });\n                    if (candidates.length > 0) {\n                        /*\n                         * at this point: different possible dmy mappings for the same i,j substring.\n                         * match the candidate date that likely takes the fewest guesses: a year closest\n                         * to 2000.\n                         * (scoring.REFERENCE_YEAR).\n                         *\n                         * ie, considering '111504', prefer 11-15-04 to 1-1-1504\n                         * (interpreting '04' as 2004)\n                         */\n                        let bestCandidate = candidates[0];\n                        let minDistance = metric(candidates[0]);\n                        candidates.slice(1).forEach((candidate) => {\n                            const distance = metric(candidate);\n                            if (distance < minDistance) {\n                                bestCandidate = candidate;\n                                minDistance = distance;\n                            }\n                        });\n                        matches.push({\n                            pattern: 'date',\n                            token,\n                            i,\n                            j,\n                            separator: '',\n                            year: bestCandidate.year,\n                            month: bestCandidate.month,\n                            day: bestCandidate.day,\n                        });\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    /*\n     * matches now contains all valid date strings in a way that is tricky to capture\n     * with regexes only. while thorough, it will contain some unintuitive noise:\n     *\n     * '2015_06_04', in addition to matching 2015_06_04, will also contain\n     * 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n     *\n     * to reduce noise, remove date matches that are strict substrings of others\n     */\n    filterNoise(matches) {\n        return matches.filter((match) => {\n            let isSubmatch = false;\n            const matchesLength = matches.length;\n            for (let o = 0; o < matchesLength; o += 1) {\n                const otherMatch = matches[o];\n                if (match !== otherMatch) {\n                    if (otherMatch.i <= match.i && otherMatch.j >= match.j) {\n                        isSubmatch = true;\n                        break;\n                    }\n                }\n            }\n            return !isSubmatch;\n        });\n    }\n    /*\n     * given a 3-tuple, discard if:\n     *   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n     *   middle int is zero\n     *   any int is over the max allowable year\n     *   any int is over two digits but under the min allowable year\n     *   2 integers are over 31, the max allowable day\n     *   2 integers are zero\n     *   all integers are over 12, the max allowable month\n     */\n    // eslint-disable-next-line complexity, max-statements\n    mapIntegersToDayMonthYear(integers) {\n        if (integers[1] > 31 || integers[1] <= 0) {\n            return null;\n        }\n        let over12 = 0;\n        let over31 = 0;\n        let under1 = 0;\n        for (let o = 0, len1 = integers.length; o < len1; o += 1) {\n            const int = integers[o];\n            if ((int > 99 && int < DATE_MIN_YEAR) || int > DATE_MAX_YEAR) {\n                return null;\n            }\n            if (int > 31) {\n                over31 += 1;\n            }\n            if (int > 12) {\n                over12 += 1;\n            }\n            if (int <= 0) {\n                under1 += 1;\n            }\n        }\n        if (over31 >= 2 || over12 === 3 || under1 >= 2) {\n            return null;\n        }\n        return this.getDayMonth(integers);\n    }\n    // eslint-disable-next-line max-statements\n    getDayMonth(integers) {\n        // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n        const possibleYearSplits = [\n            [integers[2], integers.slice(0, 2)],\n            [integers[0], integers.slice(1, 3)], // year first\n        ];\n        const possibleYearSplitsLength = possibleYearSplits.length;\n        for (let j = 0; j < possibleYearSplitsLength; j += 1) {\n            const [y, rest] = possibleYearSplits[j];\n            if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n                const dm = this.mapIntegersToDayMonth(rest);\n                if (dm != null) {\n                    return {\n                        year: y,\n                        month: dm.month,\n                        day: dm.day,\n                    };\n                }\n                /*\n                 * for a candidate that includes a four-digit year,\n                 * when the remaining integers don't match to a day and month,\n                 * it is not a date.\n                 */\n                return null;\n            }\n        }\n        // given no four-digit year, two digit years are the most flexible int to match, so\n        // try to parse a day-month out of integers[0..1] or integers[1..0]\n        for (let k = 0; k < possibleYearSplitsLength; k += 1) {\n            const [y, rest] = possibleYearSplits[k];\n            const dm = this.mapIntegersToDayMonth(rest);\n            if (dm != null) {\n                return {\n                    year: this.twoToFourDigitYear(y),\n                    month: dm.month,\n                    day: dm.day,\n                };\n            }\n        }\n        return null;\n    }\n    mapIntegersToDayMonth(integers) {\n        const temp = [integers, integers.slice().reverse()];\n        for (let i = 0; i < temp.length; i += 1) {\n            const data = temp[i];\n            const day = data[0];\n            const month = data[1];\n            if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {\n                return {\n                    day,\n                    month,\n                };\n            }\n        }\n        return null;\n    }\n    twoToFourDigitYear(year) {\n        if (year > 99) {\n            return year;\n        }\n        if (year > 50) {\n            // 87 -> 1987\n            return year + 1900;\n        }\n        // 15 -> 2015\n        return year + 2000;\n    }\n}\nexport default MatchDate;\n//# sourceMappingURL=matching.js.map","import { MIN_YEAR_SPACE, REFERENCE_YEAR } from '../../data/const';\nexport default ({ year, separator }) => {\n    // base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n    const yearSpace = Math.max(Math.abs(year - REFERENCE_YEAR), MIN_YEAR_SPACE);\n    let guesses = yearSpace * 365;\n    // add factor of 4 for separator selection (one of ~4 choices)\n    if (separator) {\n        guesses *= 4;\n    }\n    return guesses;\n};\n//# sourceMappingURL=scoring.js.map","import { zxcvbnOptions } from '../../Options';\nimport { ALL_UPPER_INVERTED, START_UPPER } from '../../data/const';\nconst getDictionaryWarningPassword = (match, isSoleMatch) => {\n    let warning = null;\n    if (isSoleMatch && !match.l33t && !match.reversed) {\n        if (match.rank <= 10) {\n            warning = zxcvbnOptions.translations.warnings.topTen;\n        }\n        else if (match.rank <= 100) {\n            warning = zxcvbnOptions.translations.warnings.topHundred;\n        }\n        else {\n            warning = zxcvbnOptions.translations.warnings.common;\n        }\n    }\n    else if (match.guessesLog10 <= 4) {\n        warning = zxcvbnOptions.translations.warnings.similarToCommon;\n    }\n    return warning;\n};\nconst getDictionaryWarningWikipedia = (match, isSoleMatch) => {\n    let warning = null;\n    if (isSoleMatch) {\n        warning = zxcvbnOptions.translations.warnings.wordByItself;\n    }\n    return warning;\n};\nconst getDictionaryWarningNames = (match, isSoleMatch) => {\n    if (isSoleMatch) {\n        return zxcvbnOptions.translations.warnings.namesByThemselves;\n    }\n    return zxcvbnOptions.translations.warnings.commonNames;\n};\nconst getDictionaryWarning = (match, isSoleMatch) => {\n    let warning = null;\n    const dictName = match.dictionaryName;\n    const isAName = dictName === 'lastnames' || dictName.toLowerCase().includes('firstnames');\n    if (dictName === 'passwords') {\n        warning = getDictionaryWarningPassword(match, isSoleMatch);\n    }\n    else if (dictName.includes('wikipedia')) {\n        warning = getDictionaryWarningWikipedia(match, isSoleMatch);\n    }\n    else if (isAName) {\n        warning = getDictionaryWarningNames(match, isSoleMatch);\n    }\n    else if (dictName === 'userInputs') {\n        warning = zxcvbnOptions.translations.warnings.userInputs;\n    }\n    return warning;\n};\nexport default (match, isSoleMatch) => {\n    const warning = getDictionaryWarning(match, isSoleMatch);\n    const suggestions = [];\n    const word = match.token;\n    if (word.match(START_UPPER)) {\n        suggestions.push(zxcvbnOptions.translations.suggestions.capitalization);\n    }\n    else if (word.match(ALL_UPPER_INVERTED) && word.toLowerCase() !== word) {\n        suggestions.push(zxcvbnOptions.translations.suggestions.allUppercase);\n    }\n    if (match.reversed && match.token.length >= 4) {\n        suggestions.push(zxcvbnOptions.translations.suggestions.reverseWords);\n    }\n    if (match.l33t) {\n        suggestions.push(zxcvbnOptions.translations.suggestions.l33t);\n    }\n    return {\n        warning,\n        suggestions,\n    };\n};\n//# sourceMappingURL=feedback.js.map","import findLevenshteinDistance from '../../levenshtein';\nimport { sorted } from '../../helper';\nimport { zxcvbnOptions } from '../../Options';\nimport Reverse from './variants/matching/reverse';\nimport L33t from './variants/matching/l33t';\nclass MatchDictionary {\n    constructor() {\n        this.l33t = new L33t(this.defaultMatch);\n        this.reverse = new Reverse(this.defaultMatch);\n    }\n    match({ password }) {\n        const matches = [\n            ...this.defaultMatch({\n                password,\n            }),\n            ...this.reverse.match({ password }),\n            ...this.l33t.match({ password }),\n        ];\n        return sorted(matches);\n    }\n    defaultMatch({ password, useLevenshtein = true }) {\n        const matches = [];\n        const passwordLength = password.length;\n        const passwordLower = password.toLowerCase();\n        // eslint-disable-next-line complexity,max-statements\n        Object.keys(zxcvbnOptions.rankedDictionaries).forEach((dictionaryName) => {\n            const rankedDict = zxcvbnOptions.rankedDictionaries[dictionaryName];\n            const longestDictionaryWordSize = zxcvbnOptions.rankedDictionariesMaxWordSize[dictionaryName];\n            const searchWidth = Math.min(longestDictionaryWordSize, passwordLength);\n            for (let i = 0; i < passwordLength; i += 1) {\n                const searchEnd = Math.min(i + searchWidth, passwordLength);\n                for (let j = i; j < searchEnd; j += 1) {\n                    const usedPassword = passwordLower.slice(i, +j + 1 || 9e9);\n                    const isInDictionary = usedPassword in rankedDict;\n                    let foundLevenshteinDistance = {};\n                    // only use levenshtein distance on full password to minimize the performance drop\n                    // and because otherwise there would be to many false positives\n                    const isFullPassword = i === 0 && j === passwordLength - 1;\n                    if (zxcvbnOptions.useLevenshteinDistance &&\n                        isFullPassword &&\n                        !isInDictionary &&\n                        useLevenshtein) {\n                        foundLevenshteinDistance = findLevenshteinDistance(usedPassword, rankedDict, zxcvbnOptions.levenshteinThreshold);\n                    }\n                    const isLevenshteinMatch = Object.keys(foundLevenshteinDistance).length !== 0;\n                    if (isInDictionary || isLevenshteinMatch) {\n                        const usedRankPassword = isLevenshteinMatch\n                            ? foundLevenshteinDistance.levenshteinDistanceEntry\n                            : usedPassword;\n                        const rank = rankedDict[usedRankPassword];\n                        matches.push({\n                            pattern: 'dictionary',\n                            i,\n                            j,\n                            token: password.slice(i, +j + 1 || 9e9),\n                            matchedWord: usedPassword,\n                            rank,\n                            dictionaryName: dictionaryName,\n                            reversed: false,\n                            l33t: false,\n                            ...foundLevenshteinDistance,\n                        });\n                    }\n                }\n            }\n        });\n        return matches;\n    }\n}\nexport default MatchDictionary;\n//# sourceMappingURL=matching.js.map","import uppercaseVariant from './variants/scoring/uppercase';\nimport l33tVariant from './variants/scoring/l33t';\nexport default ({ rank, reversed, l33t, subs, token, dictionaryName, }) => {\n    const baseGuesses = rank; // keep these as properties for display purposes\n    const uppercaseVariations = uppercaseVariant(token);\n    const l33tVariations = l33tVariant({ l33t, subs, token });\n    const reversedVariations = (reversed && 2) || 1;\n    let calculation;\n    if (dictionaryName === 'diceware') {\n        // diceware dictionaries are special, so we get a simple scoring of 1/2 of 6^5 (6 digits on 5 dice)\n        // to get fix entropy of ~12.9 bits for every entry https://en.wikipedia.org/wiki/Diceware#:~:text=The%20level%20of,bits\n        calculation = 6 ** 5 / 2;\n    }\n    else {\n        calculation =\n            baseGuesses * uppercaseVariations * l33tVariations * reversedVariations;\n    }\n    return {\n        baseGuesses,\n        uppercaseVariations,\n        l33tVariations,\n        calculation,\n    };\n};\n//# sourceMappingURL=scoring.js.map","import { zxcvbnOptions } from '../../../../Options';\nimport getCleanPasswords from './unmunger/getCleanPasswords';\nconst getExtras = (passwordWithSubs, i, j) => {\n    const previousChanges = passwordWithSubs.changes.filter((changes) => {\n        return changes.i < i;\n    });\n    const iUnsubbed = previousChanges.reduce((value, change) => {\n        return value - change.letter.length + change.substitution.length;\n    }, i);\n    const usedChanges = passwordWithSubs.changes.filter((changes) => {\n        return changes.i >= i && changes.i <= j;\n    });\n    const jUnsubbed = usedChanges.reduce((value, change) => {\n        return value - change.letter.length + change.substitution.length;\n    }, j - i + iUnsubbed);\n    const filtered = [];\n    const subDisplay = [];\n    usedChanges.forEach((value) => {\n        const existingIndex = filtered.findIndex((t) => {\n            return t.letter === value.letter && t.substitution === value.substitution;\n        });\n        if (existingIndex < 0) {\n            filtered.push({\n                letter: value.letter,\n                substitution: value.substitution,\n            });\n            subDisplay.push(`${value.substitution} -> ${value.letter}`);\n        }\n    });\n    return {\n        i: iUnsubbed,\n        j: jUnsubbed,\n        subs: filtered,\n        subDisplay: subDisplay.join(', '),\n    };\n};\n/*\n * -------------------------------------------------------------------------------\n *  Dictionary l33t matching -----------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchL33t {\n    constructor(defaultMatch) {\n        this.defaultMatch = defaultMatch;\n    }\n    isAlreadyIncluded(matches, newMatch) {\n        return matches.some((l33tMatch) => {\n            return Object.entries(l33tMatch).every(([key, value]) => {\n                return key === 'subs' || value === newMatch[key];\n            });\n        });\n    }\n    match({ password }) {\n        const matches = [];\n        const subbedPasswords = getCleanPasswords(password, zxcvbnOptions.l33tMaxSubstitutions, zxcvbnOptions.trieNodeRoot);\n        let hasFullMatch = false;\n        let isFullSubstitution = true;\n        subbedPasswords.forEach((subbedPassword) => {\n            if (hasFullMatch) {\n                return;\n            }\n            const matchedDictionary = this.defaultMatch({\n                password: subbedPassword.password,\n                useLevenshtein: isFullSubstitution,\n            });\n            // only the first entry has a full substitution\n            isFullSubstitution = false;\n            matchedDictionary.forEach((match) => {\n                if (!hasFullMatch) {\n                    hasFullMatch = match.i === 0 && match.j === password.length - 1;\n                }\n                const extras = getExtras(subbedPassword, match.i, match.j);\n                const token = password.slice(extras.i, +extras.j + 1 || 9e9);\n                const newMatch = {\n                    ...match,\n                    l33t: true,\n                    token,\n                    ...extras,\n                };\n                const alreadyIncluded = this.isAlreadyIncluded(matches, newMatch);\n                // only return the matches that contain an actual substitution\n                if (token.toLowerCase() !== match.matchedWord && !alreadyIncluded) {\n                    matches.push(newMatch);\n                }\n            });\n        });\n        // filter single-character l33t matches to reduce noise.\n        // otherwise '1' matches 'i', '4' matches 'a', both very common English words\n        // with low dictionary rank.\n        return matches.filter((match) => match.token.length > 1);\n    }\n}\nexport default MatchL33t;\n//# sourceMappingURL=l33t.js.map","/*\n * -------------------------------------------------------------------------------\n *  Dictionary reverse matching --------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchReverse {\n    constructor(defaultMatch) {\n        this.defaultMatch = defaultMatch;\n    }\n    match({ password }) {\n        const passwordReversed = password.split('').reverse().join('');\n        return this.defaultMatch({\n            password: passwordReversed,\n        }).map((match) => ({\n            ...match,\n            token: match.token.split('').reverse().join(''),\n            reversed: true,\n            // map coordinates back to original string\n            i: password.length - 1 - match.j,\n            j: password.length - 1 - match.i,\n        }));\n    }\n}\nexport default MatchReverse;\n//# sourceMappingURL=reverse.js.map","export default class TrieNode {\n    constructor(parents = []) {\n        this.parents = parents;\n        // eslint-disable-next-line no-use-before-define\n        this.children = new Map();\n    }\n    addSub(key, ...subs) {\n        const firstChar = key.charAt(0);\n        if (!this.children.has(firstChar)) {\n            this.children.set(firstChar, new TrieNode([...this.parents, firstChar]));\n        }\n        let cur = this.children.get(firstChar);\n        for (let i = 1; i < key.length; i += 1) {\n            const c = key.charAt(i);\n            if (!cur.hasChild(c)) {\n                cur.addChild(c);\n            }\n            cur = cur.getChild(c);\n        }\n        cur.subs = (cur.subs || []).concat(subs);\n        return this;\n    }\n    getChild(child) {\n        return this.children.get(child);\n    }\n    isTerminal() {\n        return !!this.subs;\n    }\n    addChild(child) {\n        if (!this.hasChild(child)) {\n            this.children.set(child, new TrieNode([...this.parents, child]));\n        }\n    }\n    hasChild(child) {\n        return this.children.has(child);\n    }\n}\n//# sourceMappingURL=TrieNode.js.map","class CleanPasswords {\n    constructor({ substr, limit, trieRoot }) {\n        this.buffer = [];\n        this.finalPasswords = [];\n        this.substr = substr;\n        this.limit = limit;\n        this.trieRoot = trieRoot;\n    }\n    getAllPossibleSubsAtIndex(index) {\n        const nodes = [];\n        let cur = this.trieRoot;\n        for (let i = index; i < this.substr.length; i += 1) {\n            const character = this.substr.charAt(i);\n            cur = cur.getChild(character);\n            if (!cur) {\n                break;\n            }\n            nodes.push(cur);\n        }\n        return nodes;\n    }\n    // eslint-disable-next-line complexity,max-statements\n    helper({ onlyFullSub, isFullSub, index, subIndex, changes, lastSubLetter, consecutiveSubCount, }) {\n        if (this.finalPasswords.length >= this.limit) {\n            return;\n        }\n        if (index === this.substr.length) {\n            if (onlyFullSub === isFullSub) {\n                this.finalPasswords.push({ password: this.buffer.join(''), changes });\n            }\n            return;\n        }\n        // first, exhaust all possible substitutions at this index\n        const nodes = [...this.getAllPossibleSubsAtIndex(index)];\n        let hasSubs = false;\n        // iterate backward to get wider substitutions first\n        for (let i = index + nodes.length - 1; i >= index; i -= 1) {\n            const cur = nodes[i - index];\n            if (cur.isTerminal()) {\n                // Skip if this would be a 4th or more consecutive substitution of the same letter\n                // this should work in all language as there shouldn't be the same letter more than four times in a row\n                // So we can ignore the rest to save calculation time\n                if (lastSubLetter === cur.parents.join('') &&\n                    consecutiveSubCount >= 3) {\n                    // eslint-disable-next-line no-continue\n                    continue;\n                }\n                hasSubs = true;\n                const subs = cur.subs;\n                // eslint-disable-next-line no-restricted-syntax\n                for (const sub of subs) {\n                    this.buffer.push(sub);\n                    const newSubs = changes.concat({\n                        i: subIndex,\n                        letter: sub,\n                        substitution: cur.parents.join(''),\n                    });\n                    // recursively build the rest of the string\n                    this.helper({\n                        onlyFullSub,\n                        isFullSub,\n                        index: i + 1,\n                        subIndex: subIndex + sub.length,\n                        changes: newSubs,\n                        lastSubLetter: cur.parents.join(''),\n                        consecutiveSubCount: lastSubLetter === cur.parents.join('')\n                            ? consecutiveSubCount + 1\n                            : 1,\n                    });\n                    // backtrack by ignoring the added postfix\n                    this.buffer.pop();\n                    if (this.finalPasswords.length >= this.limit) {\n                        return;\n                    }\n                }\n            }\n        }\n        // next, generate all combos without doing a substitution at this index\n        // if a partial substitution is requested or there are no substitutions at this index\n        if (!onlyFullSub || !hasSubs) {\n            const firstChar = this.substr.charAt(index);\n            this.buffer.push(firstChar);\n            this.helper({\n                onlyFullSub,\n                isFullSub: isFullSub && !hasSubs,\n                index: index + 1,\n                subIndex: subIndex + 1,\n                changes,\n                lastSubLetter,\n                consecutiveSubCount,\n            });\n            this.buffer.pop();\n        }\n    }\n    getAll() {\n        // only full substitution\n        this.helper({\n            onlyFullSub: true,\n            isFullSub: true,\n            index: 0,\n            subIndex: 0,\n            changes: [],\n            lastSubLetter: undefined,\n            consecutiveSubCount: 0,\n        });\n        // only partial substitution\n        this.helper({\n            onlyFullSub: false,\n            isFullSub: true,\n            index: 0,\n            subIndex: 0,\n            changes: [],\n            lastSubLetter: undefined,\n            consecutiveSubCount: 0,\n        });\n        return this.finalPasswords;\n    }\n}\nconst getCleanPasswords = (password, limit, trieRoot) => {\n    const helper = new CleanPasswords({\n        substr: password,\n        limit,\n        trieRoot,\n    });\n    return helper.getAll();\n};\nexport default getCleanPasswords;\n//# sourceMappingURL=getCleanPasswords.js.map","export default (l33tTable, triNode) => {\n    Object.entries(l33tTable).forEach(([letter, substitutions]) => {\n        substitutions.forEach((substitution) => {\n            triNode.addSub(substitution, letter);\n        });\n    });\n    return triNode;\n};\n//# sourceMappingURL=l33tTableToTrieNode.js.map","import utils from '../../../../scoring/utils';\nconst countSubstring = (string, substring) => {\n    let count = 0;\n    let pos = string.indexOf(substring);\n    while (pos >= 0) {\n        count += 1;\n        pos = string.indexOf(substring, pos + substring.length);\n    }\n    return count;\n};\nconst getCounts = ({ sub, token }) => {\n    // lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n    const tokenLower = token.toLowerCase();\n    // num of subbed chars\n    const subbedCount = countSubstring(tokenLower, sub.substitution);\n    // num of unsubbed chars\n    const unsubbedCount = countSubstring(tokenLower, sub.letter);\n    return {\n        subbedCount,\n        unsubbedCount,\n    };\n};\nexport default ({ l33t, subs, token }) => {\n    if (!l33t) {\n        return 1;\n    }\n    let variations = 1;\n    subs.forEach((sub) => {\n        const { subbedCount, unsubbedCount } = getCounts({ sub, token });\n        if (subbedCount === 0 || unsubbedCount === 0) {\n            // for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n            // treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n            // unsubbed.)\n            variations *= 2;\n        }\n        else {\n            // this case is similar to capitalization:\n            // with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n            const p = Math.min(unsubbedCount, subbedCount);\n            let possibilities = 0;\n            for (let i = 1; i <= p; i += 1) {\n                possibilities += utils.nCk(unsubbedCount + subbedCount, i);\n            }\n            variations *= possibilities;\n        }\n    });\n    return variations;\n};\n//# sourceMappingURL=l33t.js.map","import utils from '../../../../scoring/utils';\nimport { START_UPPER, END_UPPER, ALL_UPPER_INVERTED, ALL_LOWER_INVERTED, ONE_LOWER, ONE_UPPER, ALPHA_INVERTED, } from '../../../../data/const';\nconst getVariations = (cleanedWord) => {\n    const wordArray = cleanedWord.split('');\n    const upperCaseCount = wordArray.filter((char) => char.match(ONE_UPPER)).length;\n    const lowerCaseCount = wordArray.filter((char) => char.match(ONE_LOWER)).length;\n    let variations = 0;\n    const variationLength = Math.min(upperCaseCount, lowerCaseCount);\n    for (let i = 1; i <= variationLength; i += 1) {\n        variations += utils.nCk(upperCaseCount + lowerCaseCount, i);\n    }\n    return variations;\n};\nexport default (word) => {\n    // clean words of non alpha characters to remove the reward effekt to capitalize the first letter https://github.com/dropbox/zxcvbn/issues/232\n    const cleanedWord = word.replace(ALPHA_INVERTED, '');\n    if (cleanedWord.match(ALL_LOWER_INVERTED) ||\n        cleanedWord.toLowerCase() === cleanedWord) {\n        return 1;\n    }\n    // a capitalized word is the most common capitalization scheme,\n    // so it only doubles the search space (uncapitalized + capitalized).\n    // all caps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n    const commonCases = [START_UPPER, END_UPPER, ALL_UPPER_INVERTED];\n    const commonCasesLength = commonCases.length;\n    for (let i = 0; i < commonCasesLength; i += 1) {\n        const regex = commonCases[i];\n        if (cleanedWord.match(regex)) {\n            return 2;\n        }\n    }\n    // otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n    // with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n    // the number of ways to lowercase U+L letters with L lowercase letters or less.\n    return getVariations(cleanedWord);\n};\n//# sourceMappingURL=uppercase.js.map","import { zxcvbnOptions } from '../../Options';\nexport default (match) => {\n    if (match.regexName === 'recentYear') {\n        return {\n            warning: zxcvbnOptions.translations.warnings.recentYears,\n            suggestions: [\n                zxcvbnOptions.translations.suggestions.recentYears,\n                zxcvbnOptions.translations.suggestions.associatedYears,\n            ],\n        };\n    }\n    return {\n        warning: null,\n        suggestions: [],\n    };\n};\n//# sourceMappingURL=feedback.js.map","import { REGEXEN } from '../../data/const';\nimport { sorted } from '../../helper';\n/*\n * -------------------------------------------------------------------------------\n *  regex matching ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchRegex {\n    match({ password, regexes = REGEXEN }) {\n        const matches = [];\n        Object.keys(regexes).forEach((name) => {\n            const regex = regexes[name];\n            regex.lastIndex = 0; // keeps regexMatch stateless\n            let regexMatch;\n            // eslint-disable-next-line no-cond-assign\n            while ((regexMatch = regex.exec(password))) {\n                if (regexMatch) {\n                    const token = regexMatch[0];\n                    matches.push({\n                        pattern: 'regex',\n                        token,\n                        i: regexMatch.index,\n                        j: regexMatch.index + regexMatch[0].length - 1,\n                        regexName: name,\n                        regexMatch,\n                    });\n                }\n            }\n        });\n        return sorted(matches);\n    }\n}\nexport default MatchRegex;\n//# sourceMappingURL=matching.js.map","import { MIN_YEAR_SPACE, REFERENCE_YEAR } from '../../data/const';\nexport default ({ regexName, regexMatch, token, }) => {\n    const charClassBases = {\n        alphaLower: 26,\n        alphaUpper: 26,\n        alpha: 52,\n        alphanumeric: 62,\n        digits: 10,\n        symbols: 33,\n    };\n    if (regexName in charClassBases) {\n        return (charClassBases[regexName] ** token.length);\n    }\n    // TODO add more regex types for example special dates like 09.11\n    // eslint-disable-next-line default-case\n    switch (regexName) {\n        case 'recentYear':\n            // conservative estimate of year space: num years from REFERENCE_YEAR.\n            // if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n            return Math.max(Math.abs(parseInt(regexMatch[0], 10) - REFERENCE_YEAR), MIN_YEAR_SPACE);\n    }\n    return 0;\n};\n//# sourceMappingURL=scoring.js.map","import { zxcvbnOptions } from '../../Options';\nexport default (match) => {\n    let warning = zxcvbnOptions.translations.warnings.extendedRepeat;\n    if (match.baseToken.length === 1) {\n        warning = zxcvbnOptions.translations.warnings.simpleRepeat;\n    }\n    return {\n        warning,\n        suggestions: [zxcvbnOptions.translations.suggestions.repeated],\n    };\n};\n//# sourceMappingURL=feedback.js.map","import scoring from '../../scoring';\n/*\n *-------------------------------------------------------------------------------\n * repeats (aaa, abcabcabc) ------------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchRepeat {\n    // eslint-disable-next-line max-statements\n    match({ password, omniMatch }) {\n        const matches = [];\n        let lastIndex = 0;\n        while (lastIndex < password.length) {\n            const greedyMatch = this.getGreedyMatch(password, lastIndex);\n            const lazyMatch = this.getLazyMatch(password, lastIndex);\n            if (greedyMatch == null) {\n                break;\n            }\n            const { match, baseToken } = this.setMatchToken(greedyMatch, lazyMatch);\n            if (match) {\n                const j = match.index + match[0].length - 1;\n                const baseGuesses = this.getBaseGuesses(baseToken, omniMatch);\n                matches.push(this.normalizeMatch(baseToken, j, match, baseGuesses));\n                lastIndex = j + 1;\n            }\n        }\n        const hasPromises = matches.some((match) => {\n            return match instanceof Promise;\n        });\n        if (hasPromises) {\n            return Promise.all(matches);\n        }\n        return matches;\n    }\n    // eslint-disable-next-line max-params\n    normalizeMatch(baseToken, j, match, baseGuesses) {\n        const baseMatch = {\n            pattern: 'repeat',\n            i: match.index,\n            j,\n            token: match[0],\n            baseToken,\n            baseGuesses: 0,\n            repeatCount: match[0].length / baseToken.length,\n        };\n        if (baseGuesses instanceof Promise) {\n            return baseGuesses.then((resolvedBaseGuesses) => {\n                return {\n                    ...baseMatch,\n                    baseGuesses: resolvedBaseGuesses,\n                };\n            });\n        }\n        return {\n            ...baseMatch,\n            baseGuesses,\n        };\n    }\n    getGreedyMatch(password, lastIndex) {\n        const greedy = /(.+)\\1+/g;\n        greedy.lastIndex = lastIndex;\n        return greedy.exec(password);\n    }\n    getLazyMatch(password, lastIndex) {\n        const lazy = /(.+?)\\1+/g;\n        lazy.lastIndex = lastIndex;\n        return lazy.exec(password);\n    }\n    setMatchToken(greedyMatch, lazyMatch) {\n        const lazyAnchored = /^(.+?)\\1+$/;\n        let match;\n        let baseToken = '';\n        if (lazyMatch && greedyMatch[0].length > lazyMatch[0].length) {\n            // greedy beats lazy for 'aabaab'\n            // greedy: [aabaab, aab]\n            // lazy:   [aa,     a]\n            match = greedyMatch;\n            // greedy's repeated string might itself be repeated, eg.\n            // aabaab in aabaabaabaab.\n            // run an anchored lazy match on greedy's repeated string\n            // to find the shortest repeated string\n            const temp = lazyAnchored.exec(match[0]);\n            if (temp) {\n                baseToken = temp[1];\n            }\n        }\n        else {\n            // lazy beats greedy for 'aaaaa'\n            // greedy: [aaaa,  aa]\n            // lazy:   [aaaaa, a]\n            match = lazyMatch;\n            if (match) {\n                baseToken = match[1];\n            }\n        }\n        return {\n            match,\n            baseToken,\n        };\n    }\n    getBaseGuesses(baseToken, omniMatch) {\n        const matches = omniMatch.match(baseToken);\n        if (matches instanceof Promise) {\n            return matches.then((resolvedMatches) => {\n                const baseAnalysis = scoring.mostGuessableMatchSequence(baseToken, resolvedMatches);\n                return baseAnalysis.guesses;\n            });\n        }\n        const baseAnalysis = scoring.mostGuessableMatchSequence(baseToken, matches);\n        return baseAnalysis.guesses;\n    }\n}\nexport default MatchRepeat;\n//# sourceMappingURL=matching.js.map","export default ({ baseGuesses, repeatCount }) => baseGuesses * repeatCount;\n//# sourceMappingURL=scoring.js.map","export default () => {\n    // no suggestions\n    return null;\n};\n//# sourceMappingURL=feedback.js.map","import { SEPERATOR_CHARS } from '../../data/const';\nconst separatorRegex = new RegExp(`[${SEPERATOR_CHARS.join('')}]`);\n/*\n *-------------------------------------------------------------------------------\n * separators (any semi-repeated special character) -----------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchSeparator {\n    static getMostUsedSeparatorChar(password) {\n        const mostUsedSeperators = [\n            ...password\n                .split('')\n                .filter((c) => separatorRegex.test(c))\n                .reduce((memo, c) => {\n                const m = memo.get(c);\n                if (m) {\n                    memo.set(c, m + 1);\n                }\n                else {\n                    memo.set(c, 1);\n                }\n                return memo;\n            }, new Map())\n                .entries(),\n        ].sort(([_a, a], [_b, b]) => b - a);\n        if (!mostUsedSeperators.length)\n            return undefined;\n        const match = mostUsedSeperators[0];\n        // If the special character is only used once, don't treat it like a separator\n        if (match[1] < 2)\n            return undefined;\n        return match[0];\n    }\n    static getSeparatorRegex(separator) {\n        return new RegExp(`([^${separator}\\n])(${separator})(?!${separator})`, 'g');\n        // negative lookbehind can be added again in a few years when it is more supported by the browsers (currently 2023)\n        // https://github.com/zxcvbn-ts/zxcvbn/issues/202\n        // return new RegExp(`(?<!${separator})(${separator})(?!${separator})`, 'g')\n    }\n    // eslint-disable-next-line max-statements\n    match({ password }) {\n        const result = [];\n        if (password.length === 0)\n            return result;\n        const mostUsedSpecial = MatchSeparator.getMostUsedSeparatorChar(password);\n        if (mostUsedSpecial === undefined)\n            return result;\n        const isSeparator = MatchSeparator.getSeparatorRegex(mostUsedSpecial);\n        // eslint-disable-next-line no-restricted-syntax\n        for (const match of password.matchAll(isSeparator)) {\n            // eslint-disable-next-line no-continue\n            if (match.index === undefined)\n                continue;\n            // add one to the index because we changed the regex from negative lookbehind to something simple.\n            // this simple approach uses the first character before the separater too but we only need the index of the separater\n            // https://github.com/zxcvbn-ts/zxcvbn/issues/202\n            const i = match.index + 1;\n            result.push({\n                pattern: 'separator',\n                token: mostUsedSpecial,\n                i,\n                j: i,\n            });\n        }\n        return result;\n    }\n}\nexport default MatchSeparator;\n//# sourceMappingURL=matching.js.map","import { SEPERATOR_CHAR_COUNT } from '../../data/const';\nexport default () => {\n    return SEPERATOR_CHAR_COUNT;\n};\n//# sourceMappingURL=scoring.js.map","import { zxcvbnOptions } from '../../Options';\nexport default () => {\n    return {\n        warning: zxcvbnOptions.translations.warnings.sequences,\n        suggestions: [zxcvbnOptions.translations.suggestions.sequences],\n    };\n};\n//# sourceMappingURL=feedback.js.map","import { ALL_UPPER, ALL_LOWER, ALL_DIGIT } from '../../data/const';\n/*\n *-------------------------------------------------------------------------------\n * sequences (abcdef) ------------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchSequence {\n    constructor() {\n        this.MAX_DELTA = 5;\n    }\n    // eslint-disable-next-line max-statements\n    match({ password }) {\n        /*\n         * Identifies sequences by looking for repeated differences in unicode codepoint.\n         * this allows skipping, such as 9753, and also matches some extended unicode sequences\n         * such as Greek and Cyrillic alphabets.\n         *\n         * for example, consider the input 'abcdb975zy'\n         *\n         * password: a   b   c   d   b    9   7   5   z   y\n         * index:    0   1   2   3   4    5   6   7   8   9\n         * delta:      1   1   1  -2  -41  -2  -2  69   1\n         *\n         * expected result:\n         * [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n         */\n        const result = [];\n        if (password.length === 1) {\n            return [];\n        }\n        let i = 0;\n        let lastDelta = null;\n        const passwordLength = password.length;\n        for (let k = 1; k < passwordLength; k += 1) {\n            const delta = password.charCodeAt(k) - password.charCodeAt(k - 1);\n            if (lastDelta == null) {\n                lastDelta = delta;\n            }\n            if (delta !== lastDelta) {\n                const j = k - 1;\n                this.update({\n                    i,\n                    j,\n                    delta: lastDelta,\n                    password,\n                    result,\n                });\n                i = j;\n                lastDelta = delta;\n            }\n        }\n        this.update({\n            i,\n            j: passwordLength - 1,\n            delta: lastDelta,\n            password,\n            result,\n        });\n        return result;\n    }\n    update({ i, j, delta, password, result }) {\n        if (j - i > 1 || Math.abs(delta) === 1) {\n            const absoluteDelta = Math.abs(delta);\n            if (absoluteDelta > 0 && absoluteDelta <= this.MAX_DELTA) {\n                const token = password.slice(i, +j + 1 || 9e9);\n                const { sequenceName, sequenceSpace } = this.getSequence(token);\n                return result.push({\n                    pattern: 'sequence',\n                    i,\n                    j,\n                    token: password.slice(i, +j + 1 || 9e9),\n                    sequenceName,\n                    sequenceSpace,\n                    ascending: delta > 0,\n                });\n            }\n        }\n        return null;\n    }\n    getSequence(token) {\n        // TODO conservatively stick with roman alphabet size.\n        //  (this could be improved)\n        let sequenceName = 'unicode';\n        let sequenceSpace = 26;\n        if (ALL_LOWER.test(token)) {\n            sequenceName = 'lower';\n            sequenceSpace = 26;\n        }\n        else if (ALL_UPPER.test(token)) {\n            sequenceName = 'upper';\n            sequenceSpace = 26;\n        }\n        else if (ALL_DIGIT.test(token)) {\n            sequenceName = 'digits';\n            sequenceSpace = 10;\n        }\n        return {\n            sequenceName,\n            sequenceSpace,\n        };\n    }\n}\nexport default MatchSequence;\n//# sourceMappingURL=matching.js.map","export default ({ token, ascending }) => {\n    const firstChr = token.charAt(0);\n    let baseGuesses = 0;\n    const startingPoints = ['a', 'A', 'z', 'Z', '0', '1', '9'];\n    // lower guesses for obvious starting points\n    if (startingPoints.includes(firstChr)) {\n        baseGuesses = 4;\n    }\n    else if (firstChr.match(/\\d/)) {\n        baseGuesses = 10; // digits\n    }\n    else {\n        // could give a higher base for uppercase,\n        // assigning 26 to both upper and lower sequences is more conservative.\n        baseGuesses = 26;\n    }\n    // need to try a descending sequence in addition to every ascending sequence ->\n    // 2x guesses\n    if (!ascending) {\n        baseGuesses *= 2;\n    }\n    return baseGuesses * token.length;\n};\n//# sourceMappingURL=scoring.js.map","import { zxcvbnOptions } from '../../Options';\nexport default (match) => {\n    let warning = zxcvbnOptions.translations.warnings.keyPattern;\n    if (match.turns === 1) {\n        warning = zxcvbnOptions.translations.warnings.straightRow;\n    }\n    return {\n        warning,\n        suggestions: [zxcvbnOptions.translations.suggestions.longerKeyboardPattern],\n    };\n};\n//# sourceMappingURL=feedback.js.map","import { sorted, extend } from '../../helper';\nimport { zxcvbnOptions } from '../../Options';\n/*\n * ------------------------------------------------------------------------------\n * spatial match (qwerty/dvorak/keypad and so on) -----------------------------------------\n * ------------------------------------------------------------------------------\n */\nclass MatchSpatial {\n    constructor() {\n        this.SHIFTED_RX = /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/;\n    }\n    match({ password }) {\n        const matches = [];\n        Object.keys(zxcvbnOptions.graphs).forEach((graphName) => {\n            const graph = zxcvbnOptions.graphs[graphName];\n            extend(matches, this.helper(password, graph, graphName));\n        });\n        return sorted(matches);\n    }\n    checkIfShifted(graphName, password, index) {\n        if (!graphName.includes('keypad') &&\n            // initial character is shifted\n            this.SHIFTED_RX.test(password.charAt(index))) {\n            return 1;\n        }\n        return 0;\n    }\n    // eslint-disable-next-line complexity, max-statements\n    helper(password, graph, graphName) {\n        let shiftedCount;\n        const matches = [];\n        let i = 0;\n        const passwordLength = password.length;\n        while (i < passwordLength - 1) {\n            let j = i + 1;\n            let lastDirection = null;\n            let turns = 0;\n            shiftedCount = this.checkIfShifted(graphName, password, i);\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const prevChar = password.charAt(j - 1);\n                const adjacents = graph[prevChar] || [];\n                let found = false;\n                let foundDirection = -1;\n                let curDirection = -1;\n                // consider growing pattern by one character if j hasn't gone over the edge.\n                if (j < passwordLength) {\n                    const curChar = password.charAt(j);\n                    const adjacentsLength = adjacents.length;\n                    for (let k = 0; k < adjacentsLength; k += 1) {\n                        const adjacent = adjacents[k];\n                        curDirection += 1;\n                        // eslint-disable-next-line max-depth\n                        if (adjacent) {\n                            const adjacentIndex = adjacent.indexOf(curChar);\n                            // eslint-disable-next-line max-depth\n                            if (adjacentIndex !== -1) {\n                                found = true;\n                                foundDirection = curDirection;\n                                // eslint-disable-next-line max-depth\n                                if (adjacentIndex === 1) {\n                                    // # index 1 in the adjacency means the key is shifted,\n                                    // # 0 means unshifted: A vs a, % vs 5, etc.\n                                    // # for example, 'q' is adjacent to the entry '2@'.\n                                    // # @ is shifted w/ index 1, 2 is unshifted.\n                                    shiftedCount += 1;\n                                }\n                                // eslint-disable-next-line max-depth\n                                if (lastDirection !== foundDirection) {\n                                    // # adding a turn is correct even in the initial\n                                    // case when last_direction is null:\n                                    // # every spatial pattern starts with a turn.\n                                    turns += 1;\n                                    lastDirection = foundDirection;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n                // if the current pattern continued, extend j and try to grow again\n                if (found) {\n                    j += 1;\n                    // otherwise push the pattern discovered so far, if any...\n                }\n                else {\n                    // don't consider length 1 or 2 chains.\n                    if (j - i > 2) {\n                        matches.push({\n                            pattern: 'spatial',\n                            i,\n                            j: j - 1,\n                            token: password.slice(i, j),\n                            graph: graphName,\n                            turns,\n                            shiftedCount,\n                        });\n                    }\n                    // ...and then start a new search for the rest of the password.\n                    i = j;\n                    break;\n                }\n            }\n        }\n        return matches;\n    }\n}\nexport default MatchSpatial;\n//# sourceMappingURL=matching.js.map","import utils from '../../scoring/utils';\nimport { zxcvbnOptions } from '../../Options';\nconst calcAverageDegree = (graph) => {\n    let average = 0;\n    Object.keys(graph).forEach((key) => {\n        const neighbors = graph[key];\n        average += neighbors.filter((entry) => !!entry).length;\n    });\n    average /= Object.entries(graph).length;\n    return average;\n};\nconst estimatePossiblePatterns = ({ token, graph, turns, }) => {\n    const startingPosition = Object.keys(zxcvbnOptions.graphs[graph]).length;\n    const averageDegree = calcAverageDegree(zxcvbnOptions.graphs[graph]);\n    let guesses = 0;\n    const tokenLength = token.length;\n    // # estimate the number of possible patterns w/ tokenLength or less with turns or less.\n    for (let i = 2; i <= tokenLength; i += 1) {\n        const possibleTurns = Math.min(turns, i - 1);\n        for (let j = 1; j <= possibleTurns; j += 1) {\n            guesses += utils.nCk(i - 1, j - 1) * startingPosition * averageDegree ** j;\n        }\n    }\n    return guesses;\n};\nexport default ({ graph, token, shiftedCount, turns, }) => {\n    let guesses = estimatePossiblePatterns({ token, graph, turns });\n    // add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n    // math is similar to extra guesses of l33t substitutions in dictionary matches.\n    if (shiftedCount) {\n        const unShiftedCount = token.length - shiftedCount;\n        if (shiftedCount === 0 || unShiftedCount === 0) {\n            guesses *= 2;\n        }\n        else {\n            let shiftedVariations = 0;\n            for (let i = 1; i <= Math.min(shiftedCount, unShiftedCount); i += 1) {\n                shiftedVariations += utils.nCk(shiftedCount + unShiftedCount, i);\n            }\n            guesses *= shiftedVariations;\n        }\n    }\n    return Math.round(guesses);\n};\n//# sourceMappingURL=scoring.js.map","import { MIN_SUBMATCH_GUESSES_SINGLE_CHAR, MIN_SUBMATCH_GUESSES_MULTI_CHAR, } from '../data/const';\nimport utils from './utils';\nimport { zxcvbnOptions } from '../Options';\nimport bruteforceMatcher from '../matcher/bruteforce/scoring';\nimport dateMatcher from '../matcher/date/scoring';\nimport dictionaryMatcher from '../matcher/dictionary/scoring';\nimport regexMatcher from '../matcher/regex/scoring';\nimport repeatMatcher from '../matcher/repeat/scoring';\nimport sequenceMatcher from '../matcher/sequence/scoring';\nimport spatialMatcher from '../matcher/spatial/scoring';\nimport separatorMatcher from '../matcher/separator/scoring';\nconst getMinGuesses = (match, password) => {\n    let minGuesses = 1;\n    if (match.token.length < password.length) {\n        if (match.token.length === 1) {\n            minGuesses = MIN_SUBMATCH_GUESSES_SINGLE_CHAR;\n        }\n        else {\n            minGuesses = MIN_SUBMATCH_GUESSES_MULTI_CHAR;\n        }\n    }\n    return minGuesses;\n};\nconst matchers = {\n    bruteforce: bruteforceMatcher,\n    date: dateMatcher,\n    dictionary: dictionaryMatcher,\n    regex: regexMatcher,\n    repeat: repeatMatcher,\n    sequence: sequenceMatcher,\n    spatial: spatialMatcher,\n    separator: separatorMatcher,\n};\nconst getScoring = (name, match) => {\n    if (matchers[name]) {\n        return matchers[name](match);\n    }\n    if (zxcvbnOptions.matchers[name] &&\n        'scoring' in zxcvbnOptions.matchers[name]) {\n        return zxcvbnOptions.matchers[name].scoring(match);\n    }\n    return 0;\n};\n// ------------------------------------------------------------------------------\n// guess estimation -- one function per match pattern ---------------------------\n// ------------------------------------------------------------------------------\n// eslint-disable-next-line complexity, max-statements\nexport default (match, password) => {\n    const extraData = {};\n    // a match's guess estimate doesn't change. cache it.\n    if ('guesses' in match && match.guesses != null) {\n        return match;\n    }\n    const minGuesses = getMinGuesses(match, password);\n    const estimationResult = getScoring(match.pattern, match);\n    let guesses = 0;\n    if (typeof estimationResult === 'number') {\n        guesses = estimationResult;\n    }\n    else if (match.pattern === 'dictionary') {\n        guesses = estimationResult.calculation;\n        extraData.baseGuesses = estimationResult.baseGuesses;\n        extraData.uppercaseVariations = estimationResult.uppercaseVariations;\n        extraData.l33tVariations = estimationResult.l33tVariations;\n    }\n    const matchGuesses = Math.max(guesses, minGuesses);\n    return {\n        ...match,\n        ...extraData,\n        guesses: matchGuesses,\n        guessesLog10: utils.log10(matchGuesses),\n    };\n};\n//# sourceMappingURL=estimate.js.map","import utils from './utils';\nimport estimateGuesses from './estimate';\nimport { MIN_GUESSES_BEFORE_GROWING_SEQUENCE } from '../data/const';\nconst scoringHelper = {\n    password: '',\n    optimal: {},\n    excludeAdditive: false,\n    separatorRegex: undefined,\n    fillArray(size, valueType) {\n        const result = [];\n        for (let i = 0; i < size; i += 1) {\n            let value = [];\n            if (valueType === 'object') {\n                value = {};\n            }\n            result.push(value);\n        }\n        return result;\n    },\n    // helper: make bruteforce match objects spanning i to j, inclusive.\n    makeBruteforceMatch(i, j) {\n        return {\n            pattern: 'bruteforce',\n            token: this.password.slice(i, +j + 1 || 9e9),\n            i,\n            j,\n        };\n    },\n    // helper: considers whether a length-sequenceLength\n    // sequence ending at match m is better (fewer guesses)\n    // than previously encountered sequences, updating state if so.\n    update(match, sequenceLength) {\n        const k = match.j;\n        const estimatedMatch = estimateGuesses(match, this.password);\n        let pi = estimatedMatch.guesses;\n        if (sequenceLength > 1) {\n            // we're considering a length-sequenceLength sequence ending with match m:\n            // obtain the product term in the minimization function by multiplying m's guesses\n            // by the product of the length-(sequenceLength-1)\n            // sequence ending just before m, at m.i - 1.\n            pi *= this.optimal.pi[estimatedMatch.i - 1][sequenceLength - 1];\n        }\n        // calculate the minimization func\n        let g = utils.factorial(sequenceLength) * pi;\n        if (!this.excludeAdditive) {\n            g += MIN_GUESSES_BEFORE_GROWING_SEQUENCE ** (sequenceLength - 1);\n        }\n        // update state if new best.\n        // first see if any competing sequences covering this prefix,\n        // with sequenceLength or fewer matches,\n        // fare better than this sequence. if so, skip it and return.\n        let shouldSkip = false;\n        Object.keys(this.optimal.g[k]).forEach((competingPatternLength) => {\n            const competingMetricMatch = this.optimal.g[k][competingPatternLength];\n            if (parseInt(competingPatternLength, 10) <= sequenceLength) {\n                if (competingMetricMatch <= g) {\n                    shouldSkip = true;\n                }\n            }\n        });\n        if (!shouldSkip) {\n            // this sequence might be part of the final optimal sequence.\n            this.optimal.g[k][sequenceLength] = g;\n            this.optimal.m[k][sequenceLength] = estimatedMatch;\n            this.optimal.pi[k][sequenceLength] = pi;\n        }\n    },\n    // helper: evaluate bruteforce matches ending at passwordCharIndex.\n    bruteforceUpdate(passwordCharIndex) {\n        // see if a single bruteforce match spanning the passwordCharIndex-prefix is optimal.\n        let match = this.makeBruteforceMatch(0, passwordCharIndex);\n        this.update(match, 1);\n        for (let i = 1; i <= passwordCharIndex; i += 1) {\n            // generate passwordCharIndex bruteforce matches, spanning from (i=1, j=passwordCharIndex) up to (i=passwordCharIndex, j=passwordCharIndex).\n            // see if adding these new matches to any of the sequences in optimal[i-1]\n            // leads to new bests.\n            match = this.makeBruteforceMatch(i, passwordCharIndex);\n            const tmp = this.optimal.m[i - 1];\n            // eslint-disable-next-line no-loop-func\n            Object.keys(tmp).forEach((sequenceLength) => {\n                const lastMatch = tmp[sequenceLength];\n                // corner: an optimal sequence will never have two adjacent bruteforce matches.\n                // it is strictly better to have a single bruteforce match spanning the same region:\n                // same contribution to the guess product with a lower length.\n                // --> safe to skip those cases.\n                if (lastMatch.pattern !== 'bruteforce') {\n                    // try adding m to this length-sequenceLength sequence.\n                    this.update(match, parseInt(sequenceLength, 10) + 1);\n                }\n            });\n        }\n    },\n    // helper: step backwards through optimal.m starting at the end,\n    // constructing the final optimal match sequence.\n    unwind(passwordLength) {\n        const optimalMatchSequence = [];\n        let k = passwordLength - 1;\n        // find the final best sequence length and score\n        let sequenceLength = 0;\n        // eslint-disable-next-line no-loss-of-precision\n        let g = 2e308;\n        const temp = this.optimal.g[k];\n        // safety check for empty passwords\n        if (temp) {\n            Object.keys(temp).forEach((candidateSequenceLength) => {\n                const candidateMetricMatch = temp[candidateSequenceLength];\n                if (candidateMetricMatch < g) {\n                    sequenceLength = parseInt(candidateSequenceLength, 10);\n                    g = candidateMetricMatch;\n                }\n            });\n        }\n        while (k >= 0) {\n            const match = this.optimal.m[k][sequenceLength];\n            optimalMatchSequence.unshift(match);\n            k = match.i - 1;\n            sequenceLength -= 1;\n        }\n        return optimalMatchSequence;\n    },\n};\nexport default {\n    // ------------------------------------------------------------------------------\n    // search --- most guessable match sequence -------------------------------------\n    // ------------------------------------------------------------------------------\n    //\n    // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n    // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n    // for a length-n password with m candidate matches. l_max is the maximum optimal\n    // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n    // search terminates rapidly.\n    //\n    // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n    // minimizes the following function:\n    //\n    //    g = sequenceLength! * Product(m.guesses for m in sequence) + D^(sequenceLength - 1)\n    //\n    // where sequenceLength is the length of the sequence.\n    //\n    // the factorial term is the number of ways to order sequenceLength patterns.\n    //\n    // the D^(sequenceLength-1) term is another length penalty, roughly capturing the idea that an\n    // attacker will try lower-length sequences first before trying length-sequenceLength sequences.\n    //\n    // for example, consider a sequence that is date-repeat-dictionary.\n    //  - an attacker would need to try other date-repeat-dictionary combinations,\n    //    hence the product term.\n    //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n    //    ..., hence the factorial term.\n    //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n    //    sequences before length-3. assuming at minimum D guesses per pattern type,\n    //    D^(sequenceLength-1) approximates Sum(D^i for i in [1..sequenceLength-1]\n    //\n    // ------------------------------------------------------------------------------\n    mostGuessableMatchSequence(password, matches, excludeAdditive = false) {\n        scoringHelper.password = password;\n        scoringHelper.excludeAdditive = excludeAdditive;\n        const passwordLength = password.length;\n        // partition matches into sublists according to ending index j\n        let matchesByCoordinateJ = scoringHelper.fillArray(passwordLength, 'array');\n        matches.forEach((match) => {\n            matchesByCoordinateJ[match.j].push(match);\n        });\n        // small detail: for deterministic output, sort each sublist by i.\n        matchesByCoordinateJ = matchesByCoordinateJ.map((match) => match.sort((m1, m2) => m1.i - m2.i));\n        scoringHelper.optimal = {\n            // optimal.m[k][sequenceLength] holds final match in the best length-sequenceLength\n            // match sequence covering the\n            // password prefix up to k, inclusive.\n            // if there is no length-sequenceLength sequence that scores better (fewer guesses) than\n            // a shorter match sequence spanning the same prefix,\n            // optimal.m[k][sequenceLength] is undefined.\n            m: scoringHelper.fillArray(passwordLength, 'object'),\n            // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n            // optimal.pi allows for fast (non-looping) updates to the minimization function.\n            pi: scoringHelper.fillArray(passwordLength, 'object'),\n            // same structure as optimal.m -- holds the overall metric.\n            g: scoringHelper.fillArray(passwordLength, 'object'),\n        };\n        for (let k = 0; k < passwordLength; k += 1) {\n            matchesByCoordinateJ[k].forEach((match) => {\n                if (match.i > 0) {\n                    Object.keys(scoringHelper.optimal.m[match.i - 1]).forEach((sequenceLength) => {\n                        scoringHelper.update(match, parseInt(sequenceLength, 10) + 1);\n                    });\n                }\n                else {\n                    scoringHelper.update(match, 1);\n                }\n            });\n            scoringHelper.bruteforceUpdate(k);\n        }\n        const optimalMatchSequence = scoringHelper.unwind(passwordLength);\n        const optimalSequenceLength = optimalMatchSequence.length;\n        const guesses = this.getGuesses(password, optimalSequenceLength);\n        return {\n            password,\n            guesses,\n            guessesLog10: utils.log10(guesses),\n            sequence: optimalMatchSequence,\n        };\n    },\n    getGuesses(password, optimalSequenceLength) {\n        const passwordLength = password.length;\n        let guesses = 0;\n        if (password.length === 0) {\n            guesses = 1;\n        }\n        else {\n            guesses =\n                scoringHelper.optimal.g[passwordLength - 1][optimalSequenceLength];\n        }\n        return guesses;\n    },\n};\n//# sourceMappingURL=index.js.map","export default {\n    // binomial coefficients\n    // src: http://blog.plover.com/math/choose.html\n    nCk(n, k) {\n        let count = n;\n        if (k > count) {\n            return 0;\n        }\n        if (k === 0) {\n            return 1;\n        }\n        let coEff = 1;\n        for (let i = 1; i <= k; i += 1) {\n            coEff *= count;\n            coEff /= i;\n            count -= 1;\n        }\n        return coEff;\n    },\n    log10(n) {\n        if (n === 0)\n            return 0;\n        return Math.log(n) / Math.log(10); // IE doesn't support Math.log10 :(\n    },\n    log2(n) {\n        return Math.log(n) / Math.log(2);\n    },\n    factorial(num) {\n        let rval = 1;\n        for (let i = 2; i <= num; i += 1)\n            rval *= i;\n        return rval;\n    },\n};\n//# sourceMappingURL=utils.js.map","import tempAdjacencyGraphs from './adjacencyGraphs.json';\nimport diceware from './diceware.json';\nimport passwords from './passwords.json';\nconst dictionary = { diceware, passwords };\n// reinit the variable because the typescript compile will otherwise just reexport the json file which will break as it's a json file\nconst adjacencyGraphs = tempAdjacencyGraphs;\nexport { dictionary, adjacencyGraphs };\n//# sourceMappingURL=index.js.map","// This file is auto generated by data-scripts/_helpers/runtime.ts\nimport commonWords from './commonWords.json';\nimport firstnames from './firstnames.json';\nimport lastnames from './lastnames.json';\nimport wikipedia from './wikipedia.json';\nimport translations from './translations';\nconst dictionary = { commonWords, firstnames, lastnames, wikipedia };\nexport { dictionary, translations };\n//# sourceMappingURL=index.js.map","export default {\n    warnings: {\n        straightRow: 'Straight rows of keys on your keyboard are easy to guess.',\n        keyPattern: 'Short keyboard patterns are easy to guess.',\n        simpleRepeat: 'Repeated characters like \"aaa\" are easy to guess.',\n        extendedRepeat: 'Repeated character patterns like \"abcabcabc\" are easy to guess.',\n        sequences: 'Common character sequences like \"abc\" are easy to guess.',\n        recentYears: 'Recent years are easy to guess.',\n        dates: 'Dates are easy to guess.',\n        topTen: 'This is a heavily used password.',\n        topHundred: 'This is a frequently used password.',\n        common: 'This is a commonly used password.',\n        similarToCommon: 'This is similar to a commonly used password.',\n        wordByItself: 'Single words are easy to guess.',\n        namesByThemselves: 'Single names or surnames are easy to guess.',\n        commonNames: 'Common names and surnames are easy to guess.',\n        userInputs: 'There should not be any personal or page related data.',\n        pwned: 'Your password was exposed by a data breach on the Internet.',\n    },\n    suggestions: {\n        l33t: \"Avoid predictable letter substitutions like '@' for 'a'.\",\n        reverseWords: 'Avoid reversed spellings of common words.',\n        allUppercase: 'Capitalize some, but not all letters.',\n        capitalization: 'Capitalize more than the first letter.',\n        dates: 'Avoid dates and years that are associated with you.',\n        recentYears: 'Avoid recent years.',\n        associatedYears: 'Avoid years that are associated with you.',\n        sequences: 'Avoid common character sequences.',\n        repeated: 'Avoid repeated words and characters.',\n        longerKeyboardPattern: 'Use longer keyboard patterns and change typing direction multiple times.',\n        anotherWord: 'Add more words that are less common.',\n        useWords: 'Use multiple words, but avoid common phrases.',\n        noNeed: 'You can create strong passwords without using symbols, numbers, or uppercase letters.',\n        pwned: 'If you use this password elsewhere, you should change it.',\n    },\n    timeEstimation: {\n        ltSecond: 'less than a second',\n        second: '{base} second',\n        seconds: '{base} seconds',\n        minute: '{base} minute',\n        minutes: '{base} minutes',\n        hour: '{base} hour',\n        hours: '{base} hours',\n        day: '{base} day',\n        days: '{base} days',\n        month: '{base} month',\n        months: '{base} months',\n        year: '{base} year',\n        years: '{base} years',\n        centuries: 'centuries',\n    },\n};\n//# sourceMappingURL=translations.js.map","\"use strict\";\nexports.__esModule = true;\nexports.distance = exports.closest = void 0;\nvar peq = new Uint32Array(0x10000);\nvar myers_32 = function (a, b) {\n    var n = a.length;\n    var m = b.length;\n    var lst = 1 << (n - 1);\n    var pv = -1;\n    var mv = 0;\n    var sc = n;\n    var i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] |= 1 << i;\n    }\n    for (i = 0; i < m; i++) {\n        var eq = peq[b.charCodeAt(i)];\n        var xv = eq | mv;\n        eq |= ((eq & pv) + pv) ^ pv;\n        mv |= ~(eq | pv);\n        pv &= eq;\n        if (mv & lst) {\n            sc++;\n        }\n        if (pv & lst) {\n            sc--;\n        }\n        mv = (mv << 1) | 1;\n        pv = (pv << 1) | ~(xv | mv);\n        mv &= xv;\n    }\n    i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] = 0;\n    }\n    return sc;\n};\nvar myers_x = function (b, a) {\n    var n = a.length;\n    var m = b.length;\n    var mhc = [];\n    var phc = [];\n    var hsize = Math.ceil(n / 32);\n    var vsize = Math.ceil(m / 32);\n    for (var i = 0; i < hsize; i++) {\n        phc[i] = -1;\n        mhc[i] = 0;\n    }\n    var j = 0;\n    for (; j < vsize - 1; j++) {\n        var mv_1 = 0;\n        var pv_1 = -1;\n        var start_1 = j * 32;\n        var vlen_1 = Math.min(32, m) + start_1;\n        for (var k = start_1; k < vlen_1; k++) {\n            peq[b.charCodeAt(k)] |= 1 << k;\n        }\n        for (var i = 0; i < n; i++) {\n            var eq = peq[a.charCodeAt(i)];\n            var pb = (phc[(i / 32) | 0] >>> i) & 1;\n            var mb = (mhc[(i / 32) | 0] >>> i) & 1;\n            var xv = eq | mv_1;\n            var xh = ((((eq | mb) & pv_1) + pv_1) ^ pv_1) | eq | mb;\n            var ph = mv_1 | ~(xh | pv_1);\n            var mh = pv_1 & xh;\n            if ((ph >>> 31) ^ pb) {\n                phc[(i / 32) | 0] ^= 1 << i;\n            }\n            if ((mh >>> 31) ^ mb) {\n                mhc[(i / 32) | 0] ^= 1 << i;\n            }\n            ph = (ph << 1) | pb;\n            mh = (mh << 1) | mb;\n            pv_1 = mh | ~(xv | ph);\n            mv_1 = ph & xv;\n        }\n        for (var k = start_1; k < vlen_1; k++) {\n            peq[b.charCodeAt(k)] = 0;\n        }\n    }\n    var mv = 0;\n    var pv = -1;\n    var start = j * 32;\n    var vlen = Math.min(32, m - start) + start;\n    for (var k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] |= 1 << k;\n    }\n    var score = m;\n    for (var i = 0; i < n; i++) {\n        var eq = peq[a.charCodeAt(i)];\n        var pb = (phc[(i / 32) | 0] >>> i) & 1;\n        var mb = (mhc[(i / 32) | 0] >>> i) & 1;\n        var xv = eq | mv;\n        var xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n        var ph = mv | ~(xh | pv);\n        var mh = pv & xh;\n        score += (ph >>> (m - 1)) & 1;\n        score -= (mh >>> (m - 1)) & 1;\n        if ((ph >>> 31) ^ pb) {\n            phc[(i / 32) | 0] ^= 1 << i;\n        }\n        if ((mh >>> 31) ^ mb) {\n            mhc[(i / 32) | 0] ^= 1 << i;\n        }\n        ph = (ph << 1) | pb;\n        mh = (mh << 1) | mb;\n        pv = mh | ~(xv | ph);\n        mv = ph & xv;\n    }\n    for (var k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] = 0;\n    }\n    return score;\n};\nvar distance = function (a, b) {\n    if (a.length < b.length) {\n        var tmp = b;\n        b = a;\n        a = tmp;\n    }\n    if (b.length === 0) {\n        return a.length;\n    }\n    if (a.length <= 32) {\n        return myers_32(a, b);\n    }\n    return myers_x(a, b);\n};\nexports.distance = distance;\nvar closest = function (str, arr) {\n    var min_distance = Infinity;\n    var min_index = 0;\n    for (var i = 0; i < arr.length; i++) {\n        var dist = distance(str, arr[i]);\n        if (dist < min_distance) {\n            min_distance = dist;\n            min_index = i;\n        }\n    }\n    return arr[min_index];\n};\nexports.closest = closest;\n"],"names":["defaultFeedback","warning","suggestions","constructor","this","matchers","bruteforce","bruteforceMatcher","date","dateMatcher","dictionary","dictionaryMatcher","regex","regexMatcher","repeat","repeatMatcher","sequence","sequenceMatcher","spatial","spatialMatcher","separator","separatorMatcher","setDefaultSuggestions","push","zxcvbnOptions","translations","useWords","noNeed","getFeedback","score","length","extraFeedback","anotherWord","longestMatch","getLongestMatch","feedback","getMatchFeedback","unshift","slice","forEach","match","token","isSoleMatch","pattern","password","matches","promises","Object","keys","key","result","Matching","omniMatch","Promise","then","response","extend","resolve","reject","all","sorted","catch","error","Options","l33tTable","trieNodeRoot","l33tTableToTrieNode","TrieNode","userInputs","rankedDictionaries","rankedDictionariesMaxWordSize","translationKeys","graphs","useLevenshteinDistance","levenshteinThreshold","l33tMaxSubstitutions","maxLength","setRankedDictionaries","setOptions","options","setTranslations","undefined","checkCustomTranslations","Error","valid","type","translationType","rankedDictionariesMaxWorkSize","name","buildRankedDictionary","getRankedDictionariesMaxWordSize","list","data","map","el","toString","reduce","a","b","Math","max","Infinity","buildSanitizedRankedDictionary","sanitizedInputs","input","inputType","toLowerCase","extendUserInputsDictionary","newList","addMatcher","matcher","console","info","MONTH","DAY","YEAR","times","second","minute","SECOND","hour","MINUTE","day","HOUR","month","year","century","translate","displayStr","value","timeEstimation","replace","estimateAttackTimes","guesses","crackTimesSeconds","onlineThrottling100PerHour","onlineNoThrottling10PerSecond","offlineSlowHashing1e4PerSecond","offlineFastHashing1e10PerSecond","crackTimesDisplay","scenario","seconds","displayTime","guessesToScore","base","timeKeys","foundIndex","findIndex","time","round","DATE_SPLITS","REFERENCE_YEAR","Date","getFullYear","SEPERATOR_CHARS","SEPERATOR_CHAR_COUNT","recentYear","c","d","e","f","g","h","i","k","l","m","n","o","q","u","s","t","v","w","x","z","warnings","straightRow","keyPattern","simpleRepeat","extendedRepeat","sequences","recentYears","dates","topTen","topHundred","common","similarToCommon","wordByItself","namesByThemselves","commonNames","pwned","l33t","reverseWords","allUppercase","capitalization","associatedYears","repeated","longerKeyboardPattern","ltSecond","minutes","hours","days","months","years","centuries","func","wait","isImmediate","timeout","args","context","shouldCallNow","clearTimeout","setTimeout","later","apply","orderedList","counter","word","listToExtend","sort","m1","m2","j","getTime","createReturnValue","resolvedMatches","start","Feedback","timeEstimates","TimeEstimates","matchSequence","scoring","mostGuessableMatchSequence","calcTime","attackTimes","main","zxcvbn","findLevenshteinDistance","rankedDictionary","threshold","foundDistance","found","find","entry","usedThreshold","getUsedThreshold","isPasswordToShort","isThresholdLongerThanPassword","ceil","abs","foundEntryDistance","distance","isInThreshold","levenshteinDistance","levenshteinDistanceEntry","minGuesses","BRUTEFORCE_CARDINALITY","Number","POSITIVE_INFINITY","MAX_VALUE","MIN_SUBMATCH_GUESSES_SINGLE_CHAR","MIN_SUBMATCH_GUESSES_MULTI_CHAR","getMatchesWithoutSeparator","getMatchesWithSeparator","filteredMatches","filterNoise","maybeDateWithSeparator","regexMatch","exec","dmy","mapIntegersToDayMonthYear","parseInt","maybeDateNoSeparator","metric","candidate","candidates","index","bestCandidate","minDistance","filter","isSubmatch","matchesLength","otherMatch","integers","over12","over31","under1","len1","int","DATE_MIN_YEAR","DATE_MAX_YEAR","getDayMonth","possibleYearSplits","possibleYearSplitsLength","y","rest","dm","mapIntegersToDayMonth","twoToFourDigitYear","temp","reverse","MIN_YEAR_SPACE","getDictionaryWarning","dictName","dictionaryName","isAName","includes","getDictionaryWarningPassword","reversed","guessesLog10","rank","getDictionaryWarningWikipedia","getDictionaryWarningNames","START_UPPER","ALL_UPPER_INVERTED","L33t","defaultMatch","Reverse","useLevenshtein","passwordLength","passwordLower","rankedDict","longestDictionaryWordSize","searchWidth","min","searchEnd","usedPassword","isInDictionary","foundLevenshteinDistance","isFullPassword","isLevenshteinMatch","matchedWord","subs","baseGuesses","uppercaseVariations","uppercaseVariant","l33tVariations","l33tVariant","calculation","isAlreadyIncluded","newMatch","some","l33tMatch","entries","every","subbedPasswords","getCleanPasswords","hasFullMatch","isFullSubstitution","subbedPassword","matchedDictionary","extras","getExtras","passwordWithSubs","iUnsubbed","changes","change","letter","substitution","usedChanges","jUnsubbed","filtered","subDisplay","join","alreadyIncluded","passwordReversed","split","parents","children","Map","addSub","firstChar","charAt","has","set","cur","get","hasChild","addChild","getChild","concat","child","isTerminal","CleanPasswords","substr","limit","trieRoot","buffer","finalPasswords","getAllPossibleSubsAtIndex","nodes","character","helper","onlyFullSub","isFullSub","subIndex","lastSubLetter","consecutiveSubCount","hasSubs","sub","newSubs","pop","getAll","triNode","substitutions","countSubstring","string","substring","count","pos","indexOf","variations","subbedCount","unsubbedCount","getCounts","tokenLower","p","possibilities","utils","nCk","cleanedWord","ALPHA_INVERTED","ALL_LOWER_INVERTED","commonCases","END_UPPER","commonCasesLength","wordArray","upperCaseCount","char","ONE_UPPER","lowerCaseCount","ONE_LOWER","variationLength","getVariations","regexName","regexes","REGEXEN","lastIndex","charClassBases","alphaLower","alphaUpper","alpha","alphanumeric","digits","symbols","baseToken","greedyMatch","getGreedyMatch","lazyMatch","getLazyMatch","setMatchToken","getBaseGuesses","normalizeMatch","baseMatch","repeatCount","resolvedBaseGuesses","greedy","lazy","lazyAnchored","separatorRegex","RegExp","MatchSeparator","getMostUsedSeparatorChar","mostUsedSeperators","test","memo","_a","_b","getSeparatorRegex","mostUsedSpecial","isSeparator","matchAll","MAX_DELTA","lastDelta","delta","charCodeAt","update","absoluteDelta","sequenceName","sequenceSpace","getSequence","ascending","ALL_LOWER","ALL_UPPER","ALL_DIGIT","firstChr","turns","SHIFTED_RX","graphName","graph","checkIfShifted","shiftedCount","lastDirection","adjacents","foundDirection","curDirection","curChar","adjacentsLength","adjacent","adjacentIndex","estimatePossiblePatterns","startingPosition","averageDegree","average","neighbors","calcAverageDegree","tokenLength","possibleTurns","unShiftedCount","shiftedVariations","extraData","getMinGuesses","estimationResult","getScoring","matchGuesses","log10","scoringHelper","optimal","excludeAdditive","fillArray","size","valueType","makeBruteforceMatch","sequenceLength","estimatedMatch","estimateGuesses","pi","factorial","MIN_GUESSES_BEFORE_GROWING_SEQUENCE","shouldSkip","competingPatternLength","competingMetricMatch","bruteforceUpdate","passwordCharIndex","tmp","unwind","optimalMatchSequence","candidateSequenceLength","candidateMetricMatch","matchesByCoordinateJ","optimalSequenceLength","getGuesses","coEff","log","log2","num","rval","diceware","passwords","adjacencyGraphs","tempAdjacencyGraphs","commonWords","firstnames","lastnames","wikipedia","exports","__esModule","closest","peq","Uint32Array","lst","pv","mv","sc","eq","xv","myers_32","mhc","phc","hsize","vsize","mv_1","pv_1","start_1","vlen_1","pb","mh","xh","mb","ph","vlen","myers_x","str","arr","min_distance","min_index","dist"],"sourceRoot":""}