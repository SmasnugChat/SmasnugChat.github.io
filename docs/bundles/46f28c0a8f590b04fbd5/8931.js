"use strict";(self.webpackChunkelement_web=self.webpackChunkelement_web||[]).push([[8931],{"./node_modules/matrix-js-sdk/src/rendezvous/index.ts":(e,t,i)=>{i.d(t,{fF:()=>D,t6:()=>x,xB:()=>C,Fj:()=>F,Rh:()=>v,n$:()=>S,_T:()=>O,NF:()=>N,G_:()=>_,Qd:()=>b,E$:()=>E});var n=i("./node_modules/@babel/runtime/helpers/esm/defineProperty.js"),s=i("./node_modules/matrix-events-sdk/lib/index.js"),r=i("./node_modules/matrix-js-sdk/src/client.ts"),o=i("./node_modules/matrix-js-sdk/src/feature.ts"),a=i("./node_modules/matrix-js-sdk/src/logger.ts"),c=i("./node_modules/matrix-js-sdk/src/utils.ts"),l=i("./node_modules/matrix-js-sdk/src/crypto-api/index.ts"),h=function(e){return e.Start="m.login.start",e.Finish="m.login.finish",e.Progress="m.login.progress",e}(h||{}),d=function(e){return e.Success="success",e.Failure="failure",e.Verified="verified",e.Declined="declined",e.Unsupported="unsupported",e}(d||{});const u=new s.UnstableValue("login_token","org.matrix.msc3906.login_token");class v{constructor(e,t,i){(0,n.A)(this,"newDeviceId",void 0),(0,n.A)(this,"newDeviceKey",void 0),(0,n.A)(this,"ourIntent",E.RECIPROCATE_LOGIN_ON_EXISTING_DEVICE),(0,n.A)(this,"_code",void 0),this.channel=e,this.client=t,this.onFailure=i}get code(){return this._code}async generateCode(){this._code||(this._code=JSON.stringify(await this.channel.generateCode(this.ourIntent)))}async startAfterShowingCode(){const e=await this.channel.connect();a.v.info(`Connected to secure channel with checksum: ${e} our intent is ${this.ourIntent}`);let t={};try{t=await this.client.getCapabilities()}catch(e){}const i=await(0,o.yk)(await this.client.getVersions()),n=r.hx.findIn(t);if((null==n||!n.enabled)&&i.get(o.Xj.LoginTokenRequest)===o.Tj.Unsupported)return a.v.info("Server doesn't support get_login_token"),await this.send({type:h.Finish,outcome:d.Unsupported}),void await this.cancel(x.HomeserverLacksSupport);await this.send({type:h.Progress,protocols:[u.name]}),a.v.info("Waiting for other device to choose protocol");const{type:s,protocol:c,outcome:l}=await this.receive();if(s!==h.Finish)if(s===h.Progress){if(c&&u.matches(c))return e;await this.cancel(x.UnsupportedAlgorithm)}else await this.cancel(x.Unknown);else if("unsupported"===(null!=l?l:""))await this.cancel(x.UnsupportedAlgorithm);else await this.cancel(x.Unknown)}async receive(){return await this.channel.receive()}async send(e){await this.channel.send(e)}async declineLoginOnExistingDevice(){a.v.info("User declined sign in"),await this.send({type:h.Finish,outcome:d.Declined})}async approveLoginOnExistingDevice(e){await this.send({type:h.Progress,login_token:e,homeserver:this.client.baseUrl}),a.v.info("Waiting for outcome");const t=await this.receive();if(!t)return;const{outcome:i,device_id:n,device_key:s}=t;if("success"!==i)throw new Error("Linking failed");return this.newDeviceId=n,this.newDeviceKey=s,n}async verifyAndCrossSignDevice(e){var t;const i=this.client.getCrypto();if(!this.newDeviceId)throw new Error("No new device ID set");if(e.getFingerprint()!==this.newDeviceKey)throw new Error(`New device has different keys than expected: ${this.newDeviceKey} vs ${e.getFingerprint()}`);const n=this.client.getSafeUserId();a.v.info(`Marking device ${this.newDeviceId} as verified`),await i.setDeviceVerified(n,this.newDeviceId,!0),await i.crossSignDevice(this.newDeviceId);const s=null!==(t=await i.getCrossSigningKeyId(l.CrossSigningKey.Master))&&void 0!==t?t:void 0,r=this.client.getDeviceId(),o=(await i.getOwnDeviceKeys()).ed25519;await this.send({type:h.Finish,outcome:d.Verified,verifying_device_id:r,verifying_device_key:o,master_key:s})}async verifyNewDeviceOnExistingDevice(e=1e4){if(!this.newDeviceId)throw new Error("No new device to sign");if(!this.newDeviceKey)return void a.v.info("No new device key to sign");if(!this.client.getCrypto())throw new Error("Crypto not available on client");let t=await this.getOwnDevice(this.newDeviceId);if(t||(a.v.info("Going to wait for new device to be online"),await(0,c.yy)(e),t=await this.getOwnDevice(this.newDeviceId)),!t)throw new Error("Device not online within timeout");await this.verifyAndCrossSignDevice(t)}async getOwnDevice(e){var t;const i=this.client.getSafeUserId();return null===(t=(await this.client.getCrypto().getUserDeviceInfo([i])).get(i))||void 0===t?void 0:t.get(e)}async cancel(e){var t;null===(t=this.onFailure)||void 0===t||t.call(this,e),await this.channel.cancel(e)}async close(){await this.channel.close()}}var p=i("./node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/index.js"),w=i("./node_modules/matrix-js-sdk/src/http-api/index.ts"),g=i("./node_modules/matrix-js-sdk/src/oidc/index.ts");function y(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function f(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?y(Object(i),!0).forEach((function(t){(0,n.A)(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):y(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}let m=function(e){return e.Protocols="m.login.protocols",e.Protocol="m.login.protocol",e.Failure="m.login.failure",e.Success="m.login.success",e.Secrets="m.login.secrets",e.ProtocolAccepted="m.login.protocol_accepted",e.Declined="m.login.declined",e}({});class _{get checkCode(){var e;return null===(e=this.channel)||void 0===e?void 0:e.getCheckCode()}constructor(e,t,i,s){(0,n.A)(this,"ourIntent",void 0),(0,n.A)(this,"_code",void 0),(0,n.A)(this,"expectingNewDeviceId",void 0),this.channel=e,this.didScanCode=t,this.client=i,this.onFailure=s,this.ourIntent=i?p.QrCodeMode.Reciprocate:p.QrCodeMode.Login}get code(){return this._code}async generateCode(){this._code||(this.ourIntent===p.QrCodeMode.Reciprocate&&this.client?this._code=await this.channel.generateCode(this.ourIntent,this.client.getDomain()):this.ourIntent===p.QrCodeMode.Login&&(this._code=await this.channel.generateCode(this.ourIntent)))}get isExistingDevice(){return this.ourIntent===p.QrCodeMode.Reciprocate}get isNewDevice(){return!this.isExistingDevice}async negotiateProtocols(){if(a.v.info(`negotiateProtocols(isNewDevice=${this.isNewDevice} didScanCode=${this.didScanCode})`),await this.channel.connect(),this.didScanCode)if(this.isNewDevice);else{var e;let t;try{const{issuer:e}=await this.client.getAuthIssuer();t=await(0,g.k8)(e)}catch(e){a.v.error("Failed to discover OIDC metadata",e)}if(null===(e=t)||void 0===e||!e.metadata.grant_types_supported.includes(g.AO))throw await this.send({type:m.Failure,reason:S.UnsupportedProtocol}),new b("Device code grant unsupported",S.UnsupportedProtocol);await this.send({type:m.Protocols,protocols:["device_authorization_grant"],homeserver:this.client.getDomain()})}else if(this.isNewDevice){a.v.info("Waiting for protocols message");const e=await this.receive();if((null==e?void 0:e.type)===m.Failure)throw new b("Failed",e.reason);if((null==e?void 0:e.type)!==m.Protocols)throw await this.send({type:m.Failure,reason:S.UnexpectedMessageReceived}),new b("Unexpected message received",S.UnexpectedMessageReceived);return{serverName:e.homeserver}}return{}}async deviceAuthorizationGrant(){if(this.isNewDevice)throw new Error("New device flows around OIDC are not yet implemented");{a.v.info("Waiting for protocol message");const t=await this.receive();if((null==t?void 0:t.type)===m.Failure)throw new b("Failed",t.reason);if((null==t?void 0:t.type)!==m.Protocol)throw await this.send({type:m.Failure,reason:S.UnexpectedMessageReceived}),new b("Unexpected message received",S.UnexpectedMessageReceived);if(function(e){return"device_authorization_grant"===e.protocol}(t)){const{device_authorization_grant:i,device_id:n}=t,{verification_uri:s,verification_uri_complete:r}=i;let o=!0;try{var e;await(null===(e=this.client)||void 0===e?void 0:e.getDevice(n))}catch(e){e instanceof w.up&&404===e.httpStatus&&(o=!1)}if(o)throw await this.send({type:m.Failure,reason:S.DeviceAlreadyExists}),new b("Specified device ID already exists",S.DeviceAlreadyExists);return this.expectingNewDeviceId=n,{verificationUri:null!=r?r:s}}throw await this.send({type:m.Failure,reason:S.UnsupportedProtocol}),new b("Received a request for an unsupported protocol",S.UnsupportedProtocol)}}async shareSecrets(){if(this.isNewDevice){await this.send({type:m.Success}),a.v.info("Waiting for secrets message");const e=await this.receive();if((null==e?void 0:e.type)===m.Failure)throw new b("Failed",e.reason);if((null==e?void 0:e.type)!==m.Secrets)throw await this.send({type:m.Failure,reason:S.UnexpectedMessageReceived}),new b("Unexpected message received",S.UnexpectedMessageReceived);return{secrets:e}}{if(!this.expectingNewDeviceId)throw new Error("No new device ID expected");await this.send({type:m.ProtocolAccepted}),a.v.info("Waiting for outcome message");const t=await this.receive();if((null==t?void 0:t.type)===m.Failure)throw new b("Failed",t.reason);if((null==t?void 0:t.type)===m.Declined)throw new b("User declined",D.UserDeclined);if((null==t?void 0:t.type)!==m.Success)throw await this.send({type:m.Failure,reason:S.UnexpectedMessageReceived}),new b("Unexpected message",S.UnexpectedMessageReceived);const i=Date.now()+1e4;do{try{var e;if(await(null===(e=this.client)||void 0===e?void 0:e.getDevice(this.expectingNewDeviceId))){const e=await this.client.getCrypto().exportSecretsBundle();if(this.channel.cancelled)throw new b("User cancelled",S.UserCancelled);return await this.send(f({type:m.Secrets},e)),{secrets:e}}}catch(e){if(!(e instanceof w.up&&404===e.httpStatus))throw e}await(0,c.yy)(1e3)}while(Date.now()<i);throw await this.send({type:m.Failure,reason:S.DeviceNotFound}),new b("New device not found",S.DeviceNotFound)}}async receive(){return await this.channel.secureReceive()}async send(e){await this.channel.secureSend(e)}async declineLoginOnExistingDevice(){if(!this.isExistingDevice)throw new Error("Can only decline login on existing device");await this.send({type:m.Failure,reason:S.UserCancelled})}async cancel(e){var t;null===(t=this.onFailure)||void 0===t||t.call(this,e),await this.channel.cancel(e)}async close(){await this.channel.close()}}class b extends Error{constructor(e,t){super(e),this.code=t}}let x=function(e){return e.UserDeclined="user_declined",e.Unknown="unknown",e.Expired="expired",e.UserCancelled="user_cancelled",e.UnsupportedAlgorithm="unsupported_algorithm",e.UnsupportedProtocol="unsupported_protocol",e.HomeserverLacksSupport="homeserver_lacks_support",e}({}),S=function(e){return e.AuthorizationExpired="authorization_expired",e.DeviceAlreadyExists="device_already_exists",e.DeviceNotFound="device_not_found",e.UnexpectedMessageReceived="unexpected_message_received",e.UnsupportedProtocol="unsupported_protocol",e.UserCancelled="user_cancelled",e}({}),D=function(e){return e.Expired="expired",e.HomeserverLacksSupport="homeserver_lacks_support",e.InsecureChannelDetected="insecure_channel_detected",e.InvalidCode="invalid_code",e.OtherDeviceNotSignedIn="other_device_not_signed_in",e.OtherDeviceAlreadySignedIn="other_device_already_signed_in",e.Unknown="unknown",e.UserDeclined="user_declined",e.ETagMissing="etag_missing",e}({}),E=function(e){return e.LOGIN_ON_NEW_DEVICE="login.start",e.RECIPROCATE_LOGIN_ON_EXISTING_DEVICE="login.reciprocate",e}({});const A=new s.UnstableValue("http.v1","org.matrix.msc3886.http.v1");class C{constructor({onFailure:e,client:t,fallbackRzServer:i,fetchFn:s}){(0,n.A)(this,"uri",void 0),(0,n.A)(this,"etag",void 0),(0,n.A)(this,"expiresAt",void 0),(0,n.A)(this,"client",void 0),(0,n.A)(this,"fallbackRzServer",void 0),(0,n.A)(this,"fetchFn",void 0),(0,n.A)(this,"cancelled",!1),(0,n.A)(this,"_ready",!1),(0,n.A)(this,"onFailure",void 0),this.fetchFn=s,this.onFailure=e,this.client=t,this.fallbackRzServer=i}get ready(){return this._ready}async details(){if(!this.uri)throw new Error("Rendezvous not set up");return{type:A.name,uri:this.uri}}fetch(e,t){return this.fetchFn?this.fetchFn(e,t):i.g.fetch(e,t)}async getPostEndpoint(){try{if(await this.client.doesServerSupportUnstableFeature("org.matrix.msc3886"))return`${this.client.baseUrl}${w.iD.Unstable}/org.matrix.msc3886/rendezvous`}catch(e){a.v.warn("Failed to get unstable features",e)}return this.fallbackRzServer}async send(e){var t,i;if(this.cancelled)return;const n=this.uri?"PUT":"POST",s=null!==(t=this.uri)&&void 0!==t?t:await this.getPostEndpoint();if(!s)throw new Error("Invalid rendezvous URI");const r={"content-type":"application/json"};this.etag&&(r["if-match"]=this.etag);const o=await this.fetch(s,{method:n,headers:r,body:JSON.stringify(e)});if(404===o.status)return this.cancel(x.Unknown);if(this.etag=null!==(i=o.headers.get("etag"))&&void 0!==i?i:void 0,"POST"===n){var a;const e=o.headers.get("location");if(!e)throw new Error("No rendezvous URI given");const t=o.headers.get("expires");t&&(this.expiresAt=new Date(t));const i=null!==(a=o.url)&&void 0!==a?a:s;this.uri=new URL(e,`${i}${i.endsWith("/")?"":"/"}`).href,this._ready=!0}}async receive(){if(!this.uri)throw new Error("Rendezvous not set up");for(;;){if(this.cancelled)return;const i={};this.etag&&(i["if-none-match"]=this.etag);const n=await this.fetch(this.uri,{method:"GET",headers:i});if(404===n.status)return void this.cancel(x.Unknown);var e;if("application/json"!==n.headers.get("content-type"))this.etag=null!==(e=n.headers.get("etag"))&&void 0!==e?e:void 0;else if(200===n.status){var t;return this.etag=null!==(t=n.headers.get("etag"))&&void 0!==t?t:void 0,n.json()}await(0,c.yy)(1e3)}}async cancel(e){var t;if(e===x.Unknown&&this.expiresAt&&this.expiresAt.getTime()<Date.now()&&(e=x.Expired),this.cancelled=!0,this._ready=!1,null===(t=this.onFailure)||void 0===t||t.call(this,e),this.uri&&e===x.UserDeclined)try{await this.fetch(this.uri,{method:"DELETE"})}catch(e){a.v.warn(e)}}}var P=i("./node_modules/matrix-js-sdk/src/matrix.ts");class O{constructor({fetchFn:e,onFailure:t,url:i,client:s,fallbackRzServer:r}){(0,n.A)(this,"url",void 0),(0,n.A)(this,"client",void 0),(0,n.A)(this,"fallbackRzServer",void 0),(0,n.A)(this,"fetchFn",void 0),(0,n.A)(this,"onFailure",void 0),(0,n.A)(this,"etag",void 0),(0,n.A)(this,"expiresAt",void 0),(0,n.A)(this,"expiresTimer",void 0),(0,n.A)(this,"_cancelled",!1),(0,n.A)(this,"_ready",!1),this.fetchFn=e,this.onFailure=t,this.client=s,this.fallbackRzServer=r,this.url=i}get ready(){return this._ready}get cancelled(){return this._cancelled}fetch(e,t){return this.fetchFn?this.fetchFn(e,t):i.g.fetch(e,t)}async getPostEndpoint(){if(this.client)try{if(await this.client.doesServerSupportUnstableFeature("org.matrix.msc4108"))return this.client.http.getUrl("/org.matrix.msc4108/rendezvous",void 0,w.iD.Unstable).toString()}catch(e){a.v.warn("Failed to get unstable features",e)}return this.fallbackRzServer}async send(e){var t,i;if(this._cancelled)return;const n=this.url?P.Method.Put:P.Method.Post,s=null!==(t=this.url)&&void 0!==t?t:await this.getPostEndpoint();if(!s)throw new Error("Invalid rendezvous URI");const r={"content-type":"text/plain"};!this.etag&&this.url&&await this.receive(),this.etag&&(r["if-match"]=this.etag),a.v.info(`=> ${n} ${s} with ${e} if-match: ${this.etag}`);const o=await this.fetch(s,{method:n,headers:r,body:e,redirect:"follow"});if(404===o.status)return this.cancel(D.Unknown);if(this.etag=null!==(i=o.headers.get("etag"))&&void 0!==i?i:void 0,a.v.info(`Received etag: ${this.etag}`),n===P.Method.Post){const e=o.headers.get("expires");e&&(this.expiresTimer&&(clearTimeout(this.expiresTimer),this.expiresTimer=void 0),this.expiresAt=new Date(e),this.expiresTimer=setTimeout((()=>{this.expiresTimer=void 0,this.cancel(D.Expired)}),this.expiresAt.getTime()-Date.now()));const t=await o.json();if("string"!=typeof t.url)throw new Error("No rendezvous URL given");this.url=t.url,this._ready=!0}}async receive(){if(!this.url)throw new Error("Rendezvous not set up");for(;;){var e;if(this._cancelled)return;const t={};this.etag&&(t["if-none-match"]=this.etag),a.v.info(`=> GET ${this.url} if-none-match: ${this.etag}`);const i=await this.fetch(this.url,{method:P.Method.Get,headers:t});if(404===i.status)return void await this.cancel(D.Unknown);const n=null!==(e=i.headers.get("etag"))&&void 0!==e?e:void 0;if("text/plain"!==i.headers.get("content-type"))this.etag=n;else if(200===i.status){if(!n)return void await this.cancel(D.ETagMissing);this.etag=n;const e=await i.text();return a.v.info(`Received: ${e} with etag ${this.etag}`),e}await(0,c.yy)(1e3)}}async cancel(e){var t;this._cancelled||(this.expiresTimer&&(clearTimeout(this.expiresTimer),this.expiresTimer=void 0),e===D.Unknown&&this.expiresAt&&this.expiresAt.getTime()<Date.now()&&(e=D.Expired),this._cancelled=!0,this._ready=!1,null===(t=this.onFailure)||void 0===t||t.call(this,e),e!==D.UserDeclined&&e!==S.UserCancelled||await this.close())}async close(){if(this.expiresTimer&&(clearTimeout(this.expiresTimer),this.expiresTimer=void 0),this.url)try{await this.fetch(this.url,{method:P.Method.Delete})}catch(e){a.v.warn(e)}}}var I=i("./node_modules/matrix-js-sdk/src/base64.ts"),k=i("./node_modules/matrix-js-sdk/src/crypto/verification/SASDecimal.ts");const U=new(i("./node_modules/matrix-js-sdk/src/NamespacedValue.ts").qr)("m.rendezvous.v2.curve25519-aes-sha256","org.matrix.msc3903.rendezvous.v2.curve25519-aes-sha256");class F{constructor(e,t,s){(0,n.A)(this,"olmSAS",void 0),(0,n.A)(this,"ourPublicKey",void 0),(0,n.A)(this,"aesKey",void 0),(0,n.A)(this,"connected",!1),this.transport=e,this.theirPublicKey=t,this.onFailure=s,this.olmSAS=new i.g.Olm.SAS,this.ourPublicKey=(0,I.y4)(this.olmSAS.get_pubkey())}async generateCode(e){if(this.transport.ready)throw new Error("Code already generated");await this.transport.send({algorithm:U.name});return{rendezvous:{algorithm:U.name,key:(0,I.PP)(this.ourPublicKey),transport:await this.transport.details()},intent:e}}async connect(){if(this.connected)throw new Error("Channel already connected");if(!this.olmSAS)throw new Error("Channel closed");const e=!this.theirPublicKey;if(e){const e=await this.transport.receive();if(!e)throw new Error("No response from other device");const t=e,{key:i,algorithm:n}=t;if(!n||!U.matches(n)||!i)throw new b("Unsupported algorithm: "+n,x.UnsupportedAlgorithm);this.theirPublicKey=(0,I.y4)(i)}else await this.transport.send({algorithm:U.name,key:(0,I.PP)(this.ourPublicKey)});this.connected=!0,this.olmSAS.set_their_key((0,I.PP)(this.theirPublicKey));const t=e?this.ourPublicKey:this.theirPublicKey,i=e?this.theirPublicKey:this.ourPublicKey;let n=U.name;n+=`|${(0,I.PP)(t)}`,n+=`|${(0,I.PP)(i)}`;const s=this.olmSAS.generate_bytes(n,32);this.aesKey=await async function(e){if(!globalThis.crypto.subtle)throw new Error("Web Crypto is not available");return globalThis.crypto.subtle.importKey("raw",e,{name:"AES-GCM"},!1,["encrypt","decrypt"])}(s),s.fill(0);const r=this.olmSAS.generate_bytes(n,5);return(0,k.c)(Array.from(r)).join("-")}async encrypt(e){if(!globalThis.crypto.subtle)throw new Error("Web Crypto is not available");const t=new Uint8Array(32);globalThis.crypto.getRandomValues(t);const i=(new TextEncoder).encode(JSON.stringify(e)),n=await globalThis.crypto.subtle.encrypt({name:"AES-GCM",iv:t,tagLength:128},this.aesKey,i);return{iv:(0,I.PP)(t),ciphertext:(0,I.PP)(n)}}async send(e){if(!this.olmSAS)throw new Error("Channel closed");if(!this.aesKey)throw new Error("Shared secret not set up");return this.transport.send(await this.encrypt(e))}async decrypt({iv:e,ciphertext:t}){if(!t||!e)throw new Error("Missing ciphertext and/or iv");const i=(0,I.y4)(t);if(!globalThis.crypto.subtle)throw new Error("Web Crypto is not available");const n=await globalThis.crypto.subtle.decrypt({name:"AES-GCM",iv:(0,I.y4)(e),tagLength:128},this.aesKey,i);return JSON.parse((new TextDecoder).decode(new Uint8Array(n)))}async receive(){if(!this.olmSAS)throw new Error("Channel closed");if(!this.aesKey)throw new Error("Shared secret not set up");const e=await this.transport.receive();if(!e)return;const t=e;if(t.ciphertext&&t.iv)return this.decrypt(t);throw new Error("Data received but no ciphertext")}async close(){this.olmSAS&&(this.olmSAS.free(),this.olmSAS=void 0)}async cancel(e){try{await this.transport.cancel(e)}finally{await this.close()}}}class N{constructor(e,t,i){(0,n.A)(this,"secureChannel",void 0),(0,n.A)(this,"establishedChannel",void 0),(0,n.A)(this,"connected",!1),this.rendezvousSession=e,this.theirPublicKey=t,this.onFailure=i,this.secureChannel=new p.Ecies}async generateCode(e,t){const{url:i}=this.rendezvousSession;if(!i)throw new Error("No rendezvous session URL");return new p.QrCodeData(this.secureChannel.public_key(),i,e===p.QrCodeMode.Reciprocate?t:void 0).toBytes()}getCheckCode(){var e;const t=null===(e=this.establishedChannel)||void 0===e?void 0:e.check_code();if(t)return Array.from(t.as_bytes()).map((e=>""+e%10)).join("")}async connect(){if(this.connected)throw new Error("Channel already connected");if(this.theirPublicKey){const e=this.secureChannel.establish_outbound_channel(this.theirPublicKey,"MATRIX_QR_CODE_LOGIN_INITIATE");this.establishedChannel=e.channel,a.v.info("Sending LoginInitiateMessage"),await this.rendezvousSession.send(e.initial_message);{a.v.info("Waiting for LoginOkMessage");const e=await this.rendezvousSession.receive();if(!e)throw new b("No response from other device",S.UnexpectedMessageReceived);if("MATRIX_QR_CODE_LOGIN_OK"!==await this.decrypt(e))throw new b("Invalid response from other device",D.InsecureChannelDetected)}}else{a.v.info("Waiting for LoginInitiateMessage");const e=await this.rendezvousSession.receive();if(!e)throw new Error("No response from other device");const{channel:t,message:i}=this.secureChannel.establish_inbound_channel(e);if(this.establishedChannel=t,"MATRIX_QR_CODE_LOGIN_INITIATE"!==i)throw new b("Invalid response from other device",D.InsecureChannelDetected);a.v.info("LoginInitiateMessage received"),a.v.info("Sending LoginOkMessage");const n=await this.encrypt("MATRIX_QR_CODE_LOGIN_OK");await this.rendezvousSession.send(n)}this.connected=!0}async decrypt(e){if(!this.establishedChannel)throw new Error("Channel closed");return this.establishedChannel.decrypt(e)}async encrypt(e){if(!this.establishedChannel)throw new Error("Channel closed");return this.establishedChannel.encrypt(e)}async secureSend(e){if(!this.connected)throw new Error("Channel closed");const t=JSON.stringify(e);a.v.debug(`=> {"type": ${JSON.stringify(e.type)}, ...}`),await this.rendezvousSession.send(await this.encrypt(t))}async secureReceive(){if(!this.establishedChannel)throw new Error("Channel closed");const e=await this.rendezvousSession.receive();if(!e)return;const t=await this.decrypt(e),i=JSON.parse(t);return a.v.debug(`<= {"type": ${JSON.stringify(i.type)}, ...}`),i}async close(){await this.rendezvousSession.close()}async cancel(e){try{var t;await this.rendezvousSession.cancel(e),null===(t=this.onFailure)||void 0===t||t.call(this,e)}finally{await this.close()}}get cancelled(){return this.rendezvousSession.cancelled}}},"./node_modules/@vector-im/compound-web/dist/components/Form/Controls/MFA/MFA.js":(e,t,i)=>{i.d(t,{f:()=>w});var n=i("./node_modules/@babel/runtime/helpers/esm/defineProperty.js"),s=i("./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),r=i("./node_modules/react/jsx-runtime.js"),o=i("./node_modules/react/index.js");const a="_container_9zyti_18",c="_control_9zyti_33",l="_digit_9zyti_57";var h=i("./node_modules/classnames/index.js");const d=["className","length"];function u(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function v(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?u(Object(i),!0).forEach((function(t){(0,n.A)(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):u(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}const p=({filled:e,selected:t})=>(0,r.jsx)("div",{className:l,"aria-hidden":"true","data-filled":e?"":void 0,"data-selected":t?"":void 0}),w=(0,o.forwardRef)((function(e,t){let{className:i,length:n=6}=e,l=(0,s.A)(e,d);const u=h(a,i),[w,g]=o.useState(0),[y,f]=o.useState(null),m=e=>{var t;const i=e.currentTarget;g(null===(t=i.value)||void 0===t?void 0:t.length),document.activeElement!==i||null===i.selectionStart||null===i.selectionEnd?f(null):f([i.selectionStart,i.selectionEnd])};return(0,r.jsxs)("div",{className:u,children:[(0,r.jsx)("input",v(v({},l),{},{inputMode:"numeric",type:"text",minLength:0,maxLength:n,className:c,pattern:`\\d{${n}}`,autoComplete:"one-time-code",onSelect:m,onFocus:m,onBlur:m,onMouseDown:m,onMouseMove:m,onMouseUp:m,onChange:m,ref:t})),Array.from(Array(n).keys()).map((e=>(0,r.jsx)(p,{filled:e<w,selected:!!y&&e>=y[0]&&e<y[1]},e)))]})}))}}]);
//# sourceMappingURL=8931.js.map